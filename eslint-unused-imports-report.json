[{"filePath":"/Users/andyrao/Documents/projects/agv1/src/App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/DataTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/DataTableContainer.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook React.useEffect has a missing dependency: 'setShowColumnDialog'. Either include it or remove the dependency array.","line":123,"column":6,"nodeType":"ArrayExpression","endLine":123,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [setShowColumnDialog]","fix":{"range":[4993,4995],"text":"[setShowColumnDialog]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { memo, useMemo, useRef, useState } from 'react';\nimport { GridApi } from 'ag-grid-community';\nimport { DataTableProvider } from './DataTableContext';\nimport { DataTableGrid } from './DataTableGrid';\nimport { DataTableToolbar } from './DataTableToolbar';\nimport { ColumnCustomizationDialog } from './dialogs/columnSettings/ColumnCustomizationDialog';\nimport { FloatingRibbonUI } from './FloatingRibbonUI';\nimport { useColumnProcessor } from './hooks/useColumnProcessor';\nimport { useGridState } from './hooks/useGridState';\nimport { useProfileSync } from './hooks/useProfileSync';\nimport { useColumnOperations } from './hooks/useColumnOperations';\nimport { DataTableProps } from './types';\nimport { useProfileStore } from '@/components/datatable/stores/profile.store';\nimport { useTheme } from '@/components/datatable/ThemeProvider';\nimport './datatable.css';\n\n/**\n * Container component that manages the state and logic for the DataTable.\n * This component coordinates all the hooks and provides context to child components.\n */\nexport const DataTableContainer = memo(({ columnDefs, dataRow }: DataTableProps) => {\n  const gridApiRef = useRef<GridApi | null>(null);\n  const [gridApi, setGridApi] = useState<GridApi | null>(null);\n  const { saveColumnCustomizations } = useProfileStore();\n  const { theme } = useTheme();\n  \n  // Initialize grid state\n  const {\n    currentColumnDefs,\n    selectedFont,\n    showColumnDialog,\n    setCurrentColumnDefs,\n    setSelectedFont,\n    setShowColumnDialog,\n  } = useGridState(columnDefs);\n  \n  const [ribbonConfig, setRibbonConfig] = useState<{\n    targetColumn: string;\n    position: { x: number; y: number };\n  } | null>(null);\n  \n  // Process columns to ensure cellStyle functions for conditional formatting\n  // This preserves the CRITICAL ensureCellStyleForColumns functionality\n  const processedColumns = useColumnProcessor(currentColumnDefs);\n  \n  // Handle profile synchronization\n  const { handleProfileChange } = useProfileSync(setCurrentColumnDefs, setSelectedFont);\n  \n  // Handle column operations\n  const { handleApplyColumnChanges, getColumnDefsWithStyles } = useColumnOperations(\n    gridApiRef,\n    setCurrentColumnDefs\n  );\n  \n  // Initialize default profile if needed\n  React.useEffect(() => {\n    const activeProfile = useProfileStore.getState().getActiveProfile();\n    if (activeProfile && activeProfile.id === 'default-profile' && \n        !activeProfile.gridState.columnCustomizations && \n        (!activeProfile.gridState.columnDefs || activeProfile.gridState.columnDefs.length === 0)) {\n      console.log('[DataTableContainer] Initializing default profile with base columnDefs');\n      // Pass columnDefs as both current and base since this is the initial setup\n      // The first parameter is current state, second is the original base columns\n      saveColumnCustomizations(columnDefs, columnDefs);\n    }\n  }, [columnDefs, saveColumnCustomizations]);\n  \n  // Handle font changes\n  const handleFontChange = React.useCallback((font: string) => {\n    setSelectedFont(font);\n    if (gridApiRef.current) {\n      gridApiRef.current.refreshCells({ force: true });\n    }\n  }, [setSelectedFont]);\n  \n  // Refresh cells when theme changes to update conditional formatting colors\n  React.useEffect(() => {\n    if (gridApiRef.current || gridApi) {\n      // Small delay to ensure DOM classes are updated\n      setTimeout(() => {\n        gridApiRef.current?.refreshCells({ force: true });\n        gridApi?.refreshCells({ force: true });\n      }, 50);\n    }\n  }, [theme, gridApi]);\n  \n  // Listen for format-column events from context menu\n  React.useEffect(() => {\n    const handleFormatColumn = (event: Event) => {\n      const customEvent = event as CustomEvent;\n      const { colId, x, y } = customEvent.detail;\n      \n      // Position ribbon near the clicked column but ensure it's visible\n      const ribbonWidth = 450;\n      const ribbonHeight = 400;\n      const padding = 20;\n      \n      const adjustedX = Math.min(x, window.innerWidth - ribbonWidth - padding);\n      const adjustedY = Math.min(y, window.innerHeight - ribbonHeight - padding);\n      \n      setRibbonConfig({\n        targetColumn: colId,\n        position: { x: Math.max(padding, adjustedX), y: Math.max(padding, adjustedY) }\n      });\n    };\n    \n    const handleOpenColumnSettings = (_event: Event) => {\n      // const customEvent = event as CustomEvent;\n      // const { colId } = customEvent.detail; // TODO: Use for pre-selecting column\n      \n      // TODO: Open column settings dialog with specific column pre-selected\n      // For now, just open the general dialog\n      setShowColumnDialog(true);\n    };\n    \n    window.addEventListener('format-column', handleFormatColumn);\n    window.addEventListener('open-column-settings', handleOpenColumnSettings);\n    \n    return () => {\n      window.removeEventListener('format-column', handleFormatColumn);\n      window.removeEventListener('open-column-settings', handleOpenColumnSettings);\n    };\n  }, []);\n  \n  // Get column state for dialog\n  const getColumnState = React.useCallback(() => {\n    if (!gridApiRef.current) return undefined;\n    \n    const columnState = gridApiRef.current.getColumnState();\n    const allColumns = gridApiRef.current.getColumns();\n    \n    console.log('[DataTableContainer] Getting column state for dialog:', {\n      columnStateLength: columnState?.length,\n      allColumnsLength: allColumns?.length,\n      visibleColumns: allColumns?.filter(col => col.isVisible()).length,\n      hiddenColumns: allColumns?.filter(col => !col.isVisible()).length\n    });\n    \n    // Create a complete state by merging column state with actual column visibility\n    if (allColumns) {\n      const completeState = allColumns.map(column => {\n        const colId = column.getColId();\n        const existingState = columnState?.find(cs => cs.colId === colId);\n        \n        return {\n          colId: colId,\n          hide: !column.isVisible(),\n          ...existingState\n        };\n      });\n      \n      return completeState;\n    }\n    \n    return columnState;\n  }, []);\n  \n  // Create context value\n  const contextValue = useMemo(() => ({\n    processedColumns,\n    selectedFont,\n    handleFontChange,\n    showColumnDialog,\n    setShowColumnDialog,\n    gridApiRef,\n    getColumnDefsWithStyles,\n    setGridApi,\n  }), [\n    processedColumns,\n    selectedFont,\n    handleFontChange,\n    showColumnDialog,\n    setShowColumnDialog,\n    getColumnDefsWithStyles,\n  ]);\n  \n  return (\n    <DataTableProvider value={contextValue}>\n      <div className=\"h-full w-full flex flex-col overflow-hidden\">\n        <DataTableToolbar\n          onFontChange={handleFontChange}\n          onSpacingChange={() => {}} // Empty function to satisfy prop requirements\n          onOpenColumnSettings={() => setShowColumnDialog(true)}\n          gridApi={gridApi}\n          onProfileChange={handleProfileChange}\n          getColumnDefsWithStyles={getColumnDefsWithStyles}\n        />\n        \n        <DataTableGrid\n          columnDefs={processedColumns}\n          rowData={dataRow}\n          gridApiRef={gridApiRef}\n        />\n        \n        <ColumnCustomizationDialog\n          open={showColumnDialog}\n          onOpenChange={setShowColumnDialog}\n          columnDefs={processedColumns}\n          columnState={getColumnState()}\n          onApply={handleApplyColumnChanges}\n        />\n        \n        {/* Show FloatingRibbonUI when ribbon is invoked from context menu */}\n        {ribbonConfig && (\n          <FloatingRibbonUI \n            targetColumn={ribbonConfig.targetColumn}\n            initialPosition={ribbonConfig.position}\n            onClose={() => setRibbonConfig(null)}\n          />\n        )}\n      </div>\n    </DataTableProvider>\n  );\n});\n\nDataTableContainer.displayName = 'DataTableContainer';","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/DataTableContext.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Move your React context(s) to a separate file.","line":4,"column":14,"nodeType":"Identifier","messageId":"reactContext","endLine":4,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { createContext } from 'react';\nimport { DataTableContextValue } from './types';\n\nexport const DataTableContext = createContext<DataTableContextValue | undefined>(undefined);\n\nexport const DataTableProvider: React.FC<{\n  children: React.ReactNode;\n  value: DataTableContextValue;\n}> = ({ children, value }) => {\n  return (\n    <DataTableContext.Provider value={value}>\n      {children}\n    </DataTableContext.Provider>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/DataTableErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/DataTableGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/DataTableRefactored.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/DataTableToolbar.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2285,2288],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2285,2288],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":72,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2443,2446],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2443,2446],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":111,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3566,3569],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3566,3569],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":116,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":116,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3724,3727],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3724,3727],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { Button } from \"@/components/ui/button\";\nimport { Settings2, Download, FileSpreadsheet } from \"lucide-react\";\nimport { ProfileManager } from \"./ProfileManager\";\nimport { GridApi, ColDef as AgColDef, ProcessCellForExportParams } from \"ag-grid-community\";\nimport { GridProfile } from \"@/components/datatable/stores/profile.store\";\nimport { useToast } from \"@/hooks/use-toast\";\n\nconst monospaceFonts = [\n  { value: 'JetBrains Mono', label: 'JetBrains Mono' },\n  { value: 'Fira Code', label: 'Fira Code' },\n  { value: 'Source Code Pro', label: 'Source Code Pro' },\n  { value: 'IBM Plex Mono', label: 'IBM Plex Mono' },\n  { value: 'Roboto Mono', label: 'Roboto Mono' },\n  { value: 'Monaco', label: 'Monaco' },\n  { value: 'Consolas', label: 'Consolas' },\n  { value: 'Courier New', label: 'Courier New' },\n  { value: 'monospace', label: 'System Monospace' },\n];\n\ninterface DataTableToolbarProps {\n  onFontChange: (font: string) => void;\n  onSpacingChange: (spacing: string) => void;\n  onOpenColumnSettings?: () => void;\n  gridApi?: GridApi | null;\n  onProfileChange?: (profile: GridProfile) => void;\n  getColumnDefsWithStyles?: () => AgColDef[];\n}\n\nexport function DataTableToolbar({ \n  onFontChange, \n  onOpenColumnSettings,\n  gridApi,\n  onProfileChange,\n  getColumnDefsWithStyles \n}: DataTableToolbarProps) {\n  const { toast } = useToast();\n  \n  const handleExportExcel = () => {\n    if (!gridApi) {\n      toast({\n        title: \"Export failed\",\n        description: \"Grid is not ready for export\",\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    try {\n      gridApi.exportDataAsExcel({\n        fileName: `data-export-${new Date().toISOString().split('T')[0]}.xlsx`,\n        author: 'AG-Grid Export',\n        sheetName: 'Data',\n        processCellCallback: (params: ProcessCellForExportParams) => {\n          const colDef = params.column.getColDef();\n          // Use valueFormatter for export if available\n          if (colDef.valueFormatter && typeof colDef.valueFormatter === 'function') {\n            return colDef.valueFormatter({\n              value: params.value,\n              data: params.node?.data,\n              node: params.node as any,\n              colDef: colDef,\n              column: params.column,\n              api: params.api,\n              context: params.context\n            } as any);\n          }\n          return params.value;\n        }\n      });\n      \n      toast({\n        title: \"Export successful\",\n        description: \"Data exported to Excel file\",\n      });\n    } catch {\n      toast({\n        title: \"Export failed\",\n        description: \"An error occurred while exporting data\",\n        variant: \"destructive\"\n      });\n    }\n  };\n  \n  const handleExportCsv = () => {\n    if (!gridApi) {\n      toast({\n        title: \"Export failed\",\n        description: \"Grid is not ready for export\",\n        variant: \"destructive\"\n      });\n      return;\n    }\n    \n    try {\n      gridApi.exportDataAsCsv({\n        fileName: `data-export-${new Date().toISOString().split('T')[0]}.csv`,\n        processCellCallback: (params: ProcessCellForExportParams) => {\n          const colDef = params.column.getColDef();\n          // Use valueFormatter for export if available\n          if (colDef.valueFormatter && typeof colDef.valueFormatter === 'function') {\n            return colDef.valueFormatter({\n              value: params.value,\n              data: params.node?.data,\n              node: params.node as any,\n              colDef: colDef,\n              column: params.column,\n              api: params.api,\n              context: params.context\n            } as any);\n          }\n          return params.value;\n        }\n      });\n      \n      toast({\n        title: \"Export successful\",\n        description: \"Data exported to CSV file\",\n      });\n    } catch {\n      toast({\n        title: \"Export failed\",\n        description: \"An error occurred while exporting data\",\n        variant: \"destructive\"\n      });\n    }\n  };\n  return (\n    <div className=\"flex items-center justify-between p-4 border-b bg-muted/40\">\n      <div className=\"flex items-center gap-4\">\n        <ProfileManager \n          gridApi={gridApi || null} \n          onProfileChange={onProfileChange}\n          getColumnDefsWithStyles={getColumnDefsWithStyles}\n        />\n        <div className=\"border-l pl-4 flex items-center gap-2\">\n          <label htmlFor=\"font-select\" className=\"text-sm font-medium\">\n            Font:\n          </label>\n          <Select onValueChange={onFontChange} defaultValue=\"monospace\">\n            <SelectTrigger id=\"font-select\" className=\"w-[180px] h-8\">\n              <SelectValue placeholder=\"Select font\" />\n            </SelectTrigger>\n            <SelectContent>\n              {monospaceFonts.map((font) => (\n                <SelectItem key={font.value} value={font.value}>\n                  <span style={{ fontFamily: font.value }}>{font.label}</span>\n                </SelectItem>\n              ))}\n            </SelectContent>\n          </Select>\n        </div>\n      </div>\n      \n      <div className=\"flex items-center gap-2\">\n        <Button \n          variant=\"outline\" \n          size=\"sm\" \n          onClick={handleExportExcel}\n          className=\"h-8\"\n          disabled={!gridApi}\n        >\n          <FileSpreadsheet className=\"mr-2 h-4 w-4\" />\n          Excel\n        </Button>\n        <Button \n          variant=\"outline\" \n          size=\"sm\" \n          onClick={handleExportCsv}\n          className=\"h-8\"\n          disabled={!gridApi}\n        >\n          <Download className=\"mr-2 h-4 w-4\" />\n          CSV\n        </Button>\n        {onOpenColumnSettings && (\n          <Button \n            variant=\"outline\" \n            size=\"sm\" \n            onClick={onOpenColumnSettings}\n            className=\"h-8\"\n          >\n            <Settings2 className=\"mr-2 h-4 w-4\" />\n            Customize Columns\n          </Button>\n        )}\n      </div>\n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/DebugProfile.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":56,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2280,2283],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2280,2283],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":58,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2433,2436],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2433,2436],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useProfileStore } from '@/components/datatable/stores/profile.store';\nimport { Button } from '@/components/ui/button';\n\nexport function DebugProfile() {\n  const { profiles, activeProfileId } = useProfileStore();\n  const activeProfile = profiles.find(p => p.id === activeProfileId);\n\n  const debugProfile = () => {\n    console.log('=== PROFILE DEBUG ===');\n    console.log('Active Profile:', activeProfile);\n    console.log('Active Profile ID:', activeProfileId);\n    \n    if (activeProfile?.gridState.columnDefs) {\n      console.log('Column Definitions Count:', activeProfile.gridState.columnDefs.length);\n      \n      // Show first 5 columns in detail\n      const columnsWithCustomizations = activeProfile.gridState.columnDefs.filter(col => {\n        const customProps = Object.keys(col).filter(key => \n          !['field', 'headerName', 'width', 'hide', 'colId', 'sort', 'sortIndex'].includes(key)\n        );\n        return customProps.length > 0;\n      });\n      \n      console.log('Columns with customizations:', columnsWithCustomizations.length);\n      \n      columnsWithCustomizations.slice(0, 5).forEach((col, idx) => {\n        console.log(`Customized Column ${idx}:`, {\n          field: col.field,\n          headerName: col.headerName,\n          hasValueFormatter: !!col.valueFormatter,\n          hasCellStyle: !!col.cellStyle,\n          hasCellClass: !!col.cellClass,\n          hasHeaderClass: !!col.headerClass,\n          hasHeaderStyle: !!col.headerStyle,\n          hasFilter: !!col.filter,\n          cellClass: col.cellClass,\n          headerClass: col.headerClass,\n          cellStyle: col.cellStyle,\n          headerStyle: col.headerStyle,\n          cellStyleType: typeof col.cellStyle,\n          headerStyleType: typeof col.headerStyle,\n          customProperties: Object.keys(col).filter(key => \n            !['field', 'headerName', 'width', 'hide', 'colId', 'sort', 'sortIndex'].includes(key)\n          )\n        });\n      });\n    }\n    \n    // Check localStorage directly\n    const storedData = localStorage.getItem('grid-profile-storage');\n    if (storedData) {\n      const parsed = JSON.parse(storedData);\n      console.log('Raw localStorage data:', parsed);\n      \n      // Check specific profile\n      const profile = parsed.state.profiles.find((p: any) => p.id === activeProfileId);\n      if (profile?.gridState?.columnDefs) {\n        const firstColWithStyle = profile.gridState.columnDefs.find((col: any) => col.cellStyle || col.headerStyle);\n        if (firstColWithStyle) {\n          console.log('First column with styles from localStorage:', {\n            field: firstColWithStyle.field,\n            cellStyle: firstColWithStyle.cellStyle,\n            headerStyle: firstColWithStyle.headerStyle,\n            cellClass: firstColWithStyle.cellClass,\n            headerClass: firstColWithStyle.headerClass\n          });\n          \n          // Show the actual headerStyle content\n          if (firstColWithStyle.headerStyle) {\n            console.log('HeaderStyle details:', firstColWithStyle.headerStyle);\n          }\n        }\n        console.log('First column full data:', profile.gridState.columnDefs[0]);\n      }\n    }\n  };\n\n  return (\n    <div className=\"fixed bottom-4 right-4 z-50\">\n      <Button onClick={debugProfile} variant=\"outline\" size=\"sm\">\n        Debug Profile\n      </Button>\n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/FloatingRibbon.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/FloatingRibbonUI.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/LazyAgGrid.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":95,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":95,"endColumn":27},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":100,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":100,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { lazy, useEffect } from 'react';\nimport { Skeleton } from '@/components/ui/skeleton';\n\n// Lazy load AG-Grid modules\nconst loadAgGridModules = () => {\n  // perfMonitor.mark('ag-grid-load-start');\n  \n  return Promise.all([\n    import('ag-grid-community'),\n    import('ag-grid-enterprise'),\n    import('ag-grid-react')\n  ]).then(([community, enterprise, react]) => {\n    // Register modules\n    community.ModuleRegistry.registerModules([enterprise.AllEnterpriseModule]);\n    \n    // perfMonitor.mark('ag-grid-load-end');\n    // perfMonitor.measure('agGridLoadTime', 'ag-grid-load-start', 'ag-grid-load-end');\n    \n    return {\n      ...community,\n      ...enterprise,\n      AgGridReact: react.AgGridReact\n    };\n  });\n};\n\n// Grid skeleton component\nexport const GridSkeleton = () => {\n  return (\n    <div className=\"h-full w-full flex flex-col p-4 space-y-4\">\n      {/* Toolbar skeleton */}\n      <div className=\"flex items-center justify-between gap-4\">\n        <div className=\"flex items-center gap-2\">\n          <Skeleton className=\"h-9 w-32\" />\n          <Skeleton className=\"h-9 w-24\" />\n          <Skeleton className=\"h-9 w-24\" />\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <Skeleton className=\"h-9 w-36\" />\n          <Skeleton className=\"h-9 w-32\" />\n        </div>\n      </div>\n      \n      {/* Grid skeleton */}\n      <div className=\"flex-1 border rounded-md overflow-hidden\">\n        {/* Header */}\n        <div className=\"h-12 bg-muted/50 border-b flex\">\n          {Array.from({ length: 8 }).map((_, i) => (\n            <div key={i} className=\"flex-1 p-3 border-r\">\n              <Skeleton className=\"h-4 w-full\" />\n            </div>\n          ))}\n        </div>\n        \n        {/* Rows */}\n        <div className=\"space-y-0\">\n          {Array.from({ length: 12 }).map((_, rowIndex) => (\n            <div key={rowIndex} className=\"h-10 border-b flex\">\n              {Array.from({ length: 8 }).map((_, colIndex) => (\n                <div key={colIndex} className=\"flex-1 p-2 border-r\">\n                  <Skeleton className=\"h-4 w-full\" />\n                </div>\n              ))}\n            </div>\n          ))}\n        </div>\n      </div>\n      \n      {/* Loading indicator */}\n      <div className=\"absolute inset-0 flex items-center justify-center bg-background/80 backdrop-blur-sm\">\n        <div className=\"text-center space-y-2\">\n          <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto\"></div>\n          <p className=\"text-sm text-muted-foreground\">Loading grid...</p>\n        </div>\n      </div>\n    </div>\n  );\n};\n\n// Export the lazy-loaded DataTable\nexport const LazyDataTable = lazy(() => {\n  // perfMonitor.mark('datatable-import-start');\n  \n  return import('./DataTable').then(module => {\n    // perfMonitor.mark('datatable-import-end');\n    // perfMonitor.measure('dataTableImportTime', 'datatable-import-start', 'datatable-import-end');\n    \n    return {\n      default: module.DataTable\n    };\n  });\n});\n\n// Preload AG-Grid modules function\nexport const preloadAgGrid = () => {\n  return loadAgGridModules();\n};\n\n// Hook to preload on idle\nexport const usePreloadAgGrid = () => {\n  useEffect(() => {\n    if ('requestIdleCallback' in window) {\n      const handle = requestIdleCallback(() => {\n        preloadAgGrid();\n      }, { timeout: 2000 });\n      \n      return () => cancelIdleCallback(handle);\n    } else {\n      // Fallback for browsers without requestIdleCallback\n      const timer = setTimeout(() => {\n        preloadAgGrid();\n      }, 1000);\n      \n      return () => clearTimeout(timer);\n    }\n  }, []);\n};","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/ProfileManager.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/ThemeProvider.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":50,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":50,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createContext, useContext, useEffect, useState } from 'react';\n\ntype Theme = 'dark' | 'light';\n\ntype ThemeProviderProps = {\n  children: React.ReactNode;\n  defaultTheme?: Theme;\n  enableSystem?: boolean;\n};\n\ntype ThemeProviderState = {\n  theme: Theme;\n  setTheme: (theme: Theme) => void;\n};\n\nconst initialState: ThemeProviderState = {\n  theme: 'dark',\n  setTheme: () => null,\n};\n\nconst ThemeProviderContext = createContext<ThemeProviderState>(initialState);\n\nexport function ThemeProvider({\n  children,\n  defaultTheme = 'dark',\n  ...props\n}: ThemeProviderProps) {\n  const [theme, setTheme] = useState<Theme>(defaultTheme);\n\n  useEffect(() => {\n    const root = window.document.documentElement;\n    root.classList.remove('light', 'dark');\n    root.classList.add(theme);\n  }, [theme]);\n\n  const value = {\n    theme,\n    setTheme: (theme: Theme) => {\n      setTheme(theme);\n    },\n  };\n\n  return (\n    <ThemeProviderContext.Provider {...props} value={value}>\n      {children}\n    </ThemeProviderContext.Provider>\n  );\n}\n\nexport const useTheme = () => {\n  const context = useContext(ThemeProviderContext);\n\n  if (context === undefined)\n    throw new Error('useTheme must be used within a ThemeProvider');\n\n  return context;\n};","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/ThemeToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/ColumnCustomizationDialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/components/AlignmentIconPicker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/components/CollapsibleSection.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/components/CustomizationBadges.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/components/FormatWizard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/components/MixedValueInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/components/NumericInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/components/OptimizedSelect.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/components/ThreeStateCheckbox.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/editors/StyleEditor.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/editors/ValueFormatterEditor.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a missing dependency: 'columnType'. Either include it or remove the dependency array.","line":723,"column":7,"nodeType":"ArrayExpression","endLine":723,"endColumn":69,"suggestions":[{"desc":"Update the dependencies array to be: [columnType, generateFormatter, generateCellStyle]","fix":{"range":[24843,24905],"text":"[columnType, generateFormatter, generateCellStyle]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useMemo } from 'react';\nimport { FormatterFunction, SerializedDefaultFallback } from '@/components/datatable/types';\nimport {\n  Dialog,\n  DialogContent,\n  DialogHeader,\n  DialogTitle,\n  DialogFooter,\n} from '@/components/ui/dialog';\nimport { Button } from '@/components/ui/button';\nimport { Label } from '@/components/ui/label';\nimport { Input } from '@/components/ui/input';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Separator } from '@/components/ui/separator';\nimport { Switch } from '@/components/ui/switch';\nimport { ScrollArea } from '@/components/ui/scroll-area';\nimport { \n  Plus, \n  Trash2, \n  Eye, \n  Palette,\n  ArrowUp,\n  ArrowDown,\n  Settings,\n  Copy,\n  Check\n} from 'lucide-react';\n\ninterface ValueFormatterEditorProps {\n  open: boolean;\n  onOpenChange: (open: boolean) => void;\n  initialFormatter?: (params: { value: unknown }) => string;\n  onSave: (formatter: (params: { value: unknown }) => string, cellStyle?: (params: { value: unknown }) => React.CSSProperties | undefined) => void;\n  title: string;\n  columnType?: 'text' | 'number' | 'date' | 'boolean';\n}\n\ninterface FormattingRule {\n  id: string;\n  condition: {\n    type: 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'greaterThan' | 'lessThan' | 'greaterEqual' | 'lessEqual' | 'between' | 'isEmpty' | 'isNotEmpty';\n    value: string;\n    value2?: string; // for 'between' condition\n  };\n  display: {\n    type: 'text' | 'original' | 'custom';\n    text: string;\n  };\n  styling: {\n    backgroundColor?: string;\n    textColor?: string;\n    fontSize?: number;\n    fontWeight?: 'normal' | 'bold' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\n    fontStyle?: 'normal' | 'italic';\n    textDecoration?: 'none' | 'underline' | 'line-through';\n    textAlign?: 'left' | 'center' | 'right';\n    border?: {\n      width: number;\n      style: 'solid' | 'dashed' | 'dotted' | 'double';\n      color: string;\n      sides: {\n        top: boolean;\n        right: boolean;\n        bottom: boolean;\n        left: boolean;\n      };\n    };\n    padding?: {\n      top: number;\n      right: number;\n      bottom: number;\n      left: number;\n    };\n  };\n  enabled: boolean;\n}\n\nconst DEFAULT_RULE: Omit<FormattingRule, 'id'> = {\n  condition: {\n    type: 'equals',\n    value: ''\n  },\n  display: {\n    type: 'custom',\n    text: ''\n  },\n  styling: {\n    // All styling properties start as undefined - only apply what user explicitly sets\n    backgroundColor: undefined,\n    textColor: undefined,\n    fontSize: undefined,\n    fontWeight: undefined,\n    fontStyle: undefined,\n    textDecoration: undefined,\n    textAlign: undefined,\n    border: {\n      width: 0,\n      style: 'solid',\n      color: '#000000',\n      sides: {\n        top: false,\n        right: false,\n        bottom: false,\n        left: false\n      }\n    },\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  },\n  enabled: true\n};\n\nconst CONDITION_OPTIONS = [\n  { value: 'equals', label: 'Equals', needsValue: true, needsValue2: false },\n  { value: 'contains', label: 'Contains', needsValue: true, needsValue2: false },\n  { value: 'startsWith', label: 'Starts with', needsValue: true, needsValue2: false },\n  { value: 'endsWith', label: 'Ends with', needsValue: true, needsValue2: false },\n  { value: 'greaterThan', label: 'Greater than', needsValue: true, needsValue2: false },\n  { value: 'lessThan', label: 'Less than', needsValue: true, needsValue2: false },\n  { value: 'greaterEqual', label: 'Greater than or equal', needsValue: true, needsValue2: false },\n  { value: 'lessEqual', label: 'Less than or equal', needsValue: true, needsValue2: false },\n  { value: 'between', label: 'Between', needsValue: true, needsValue2: true },\n  { value: 'isEmpty', label: 'Is empty', needsValue: false, needsValue2: false },\n  { value: 'isNotEmpty', label: 'Is not empty', needsValue: false, needsValue2: false }\n];\n\nconst SAMPLE_DATA = {\n  text: ['Sample Text', 'Hello World', 'Test', '', 'Option1'],\n  number: [1, 25, 100, 0, -5, 150],\n  date: ['2024-01-15', '2024-12-25', '2024-06-30'],\n  boolean: [true, false, true]\n};\n\nexport const ValueFormatterEditor: React.FC<ValueFormatterEditorProps> = ({\n  open,\n  onOpenChange,\n  initialFormatter,\n  onSave,\n  title,\n  columnType = 'text'\n}) => {\n  const [rules, setRules] = useState<FormattingRule[]>([]);\n  const [defaultFallback, setDefaultFallback] = useState<SerializedDefaultFallback>({\n    display: { type: 'original', text: '' },\n    styling: {\n      // Default fallback styling also starts undefined - no styles unless explicitly set\n      backgroundColor: undefined,\n      textColor: undefined,\n      fontSize: undefined,\n      fontWeight: undefined,\n      fontStyle: undefined,\n      textDecoration: undefined,\n      textAlign: undefined,\n      border: {\n        width: 0,\n        style: 'solid' as const,\n        color: '#000000',\n        sides: {\n          top: false,\n          right: false,\n          bottom: false,\n          left: false\n        }\n      },\n      padding: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      }\n    }\n  });\n  const [copiedFormatter, setCopiedFormatter] = useState(false);\n  const [copiedCellStyle, setCopiedCellStyle] = useState(false);\n  const [copiedExcel, setCopiedExcel] = useState(false);\n\n  // Initialize rules from existing formatter\n  useEffect(() => {\n    if (initialFormatter && typeof initialFormatter === 'function') {\n      // Check if the formatter has visual editor metadata\n      const visualRules = (initialFormatter as unknown as FormatterFunction).__visualRules;\n      const visualDefaultFallback = (initialFormatter as unknown as FormatterFunction).__visualDefaultFallback;\n      \n      console.log('[ValueFormatterEditor] Initializing from existing formatter:', {\n        hasVisualRules: !!visualRules,\n        hasDefaultFallback: !!visualDefaultFallback,\n        rulesCount: visualRules?.length || 0\n      });\n      \n      if (visualRules && Array.isArray(visualRules)) {\n        // Restore the original rules\n        setRules(visualRules);\n        console.log('[ValueFormatterEditor] Restored', visualRules.length, 'rules from metadata');\n      } else {\n        // No visual rules available - start with empty rules\n        setRules([]);\n        console.log('[ValueFormatterEditor] No visual rules found - starting with empty rules');\n      }\n      \n      if (visualDefaultFallback) {\n        // Restore the default fallback\n        setDefaultFallback(visualDefaultFallback);\n        console.log('[ValueFormatterEditor] Restored default fallback from metadata');\n      }\n    } else {\n      setRules([]);\n    }\n  }, [initialFormatter]);\n\n  const addRule = () => {\n    const newRule: FormattingRule = {\n      id: Date.now().toString(),\n      ...DEFAULT_RULE\n    };\n    setRules(prev => [...prev, newRule]);\n  };\n\n  const updateRule = (id: string, updates: Partial<FormattingRule>) => {\n    setRules(prev => prev.map(rule => \n      rule.id === id ? { ...rule, ...updates } : rule\n    ));\n  };\n\n  const deleteRule = (id: string) => {\n    setRules(prev => prev.filter(rule => rule.id !== id));\n  };\n\n  const moveRule = (id: string, direction: 'up' | 'down') => {\n    setRules(prev => {\n      const index = prev.findIndex(rule => rule.id === id);\n      if (index === -1) return prev;\n      \n      const newIndex = direction === 'up' ? index - 1 : index + 1;\n      if (newIndex < 0 || newIndex >= prev.length) return prev;\n      \n      const newRules = [...prev];\n      [newRules[index], newRules[newIndex]] = [newRules[newIndex], newRules[index]];\n      return newRules;\n    });\n  };\n\n  // Check if a value matches a condition\n  const matchesCondition = (value: unknown, condition: FormattingRule['condition']): boolean => {\n    const strValue = String(value || '');\n    const numValue = Number(value);\n    \n    switch (condition.type) {\n      case 'equals':\n        return strValue === condition.value;\n      case 'contains':\n        return strValue.toLowerCase().includes(condition.value.toLowerCase());\n      case 'startsWith':\n        return strValue.toLowerCase().startsWith(condition.value.toLowerCase());\n      case 'endsWith':\n        return strValue.toLowerCase().endsWith(condition.value.toLowerCase());\n      case 'greaterThan':\n        return !isNaN(numValue) && numValue > Number(condition.value);\n      case 'lessThan':\n        return !isNaN(numValue) && numValue < Number(condition.value);\n      case 'greaterEqual':\n        return !isNaN(numValue) && numValue >= Number(condition.value);\n      case 'lessEqual':\n        return !isNaN(numValue) && numValue <= Number(condition.value);\n      case 'between':\n        return !isNaN(numValue) && numValue >= Number(condition.value) && numValue <= Number(condition.value2 || condition.value);\n      case 'isEmpty':\n        return strValue === '';\n      case 'isNotEmpty':\n        return strValue !== '';\n      default:\n        return false;\n    }\n  };\n\n  // Generate display text based on rule\n  const getDisplayText = (value: unknown, display: FormattingRule['display']): string => {\n    switch (display.type) {\n      case 'original':\n        return String(value || '');\n      case 'text':\n      case 'custom':\n        return display.text;\n      default:\n        return String(value || '');\n    }\n  };\n\n  // Convert styling object to CSS properties - only include explicitly set properties\n  const styleToCss = (styling: FormattingRule['styling']): React.CSSProperties => {\n    const css: React.CSSProperties = {};\n\n    // Only include properties that are explicitly defined (not undefined)\n    if (styling.backgroundColor !== undefined) {\n      css.backgroundColor = styling.backgroundColor;\n    }\n    if (styling.textColor !== undefined) {\n      css.color = styling.textColor;\n    }\n    if (styling.fontSize !== undefined) {\n      css.fontSize = `${styling.fontSize}px`;\n    }\n    if (styling.fontWeight !== undefined) {\n      css.fontWeight = styling.fontWeight;\n    }\n    if (styling.fontStyle !== undefined) {\n      css.fontStyle = styling.fontStyle;\n    }\n    if (styling.textDecoration !== undefined) {\n      css.textDecoration = styling.textDecoration;\n    }\n    if (styling.textAlign !== undefined) {\n      css.textAlign = styling.textAlign;\n    }\n\n    // Handle padding - only if any side has a value > 0\n    if (styling.padding && (styling.padding.top > 0 || styling.padding.right > 0 || styling.padding.bottom > 0 || styling.padding.left > 0)) {\n      css.padding = `${styling.padding.top}px ${styling.padding.right}px ${styling.padding.bottom}px ${styling.padding.left}px`;\n    }\n\n    // Handle borders - only if width > 0 and at least one side is enabled\n    if (styling.border && styling.border.width > 0 && (styling.border.sides.top || styling.border.sides.right || styling.border.sides.bottom || styling.border.sides.left)) {\n      const borderStyle = `${styling.border.width}px ${styling.border.style} ${styling.border.color}`;\n      if (styling.border.sides.top) css.borderTop = borderStyle;\n      if (styling.border.sides.right) css.borderRight = borderStyle;\n      if (styling.border.sides.bottom) css.borderBottom = borderStyle;\n      if (styling.border.sides.left) css.borderLeft = borderStyle;\n    }\n\n    console.log('[ValueFormatterEditor] styleToCss generated:', css);\n    return css;\n  };\n\n  // Generate the formatter function\n  const generateFormatter = (): (params: { value: unknown }) => string => {\n    return (params: { value: unknown }) => {\n      const value = params.value;\n      \n      // Check each rule in order\n      for (const rule of rules) {\n        if (rule.enabled && matchesCondition(value, rule.condition)) {\n          return getDisplayText(value, rule.display);\n        }\n      }\n      \n      // Fallback to default\n      return getDisplayText(value, defaultFallback.display);\n    };\n  };\n\n  // Generate the cell style function\n  const generateCellStyle = (): (params: { value: unknown }) => React.CSSProperties | undefined => {\n    return (params: { value: unknown }) => {\n      const value = params.value;\n      \n      // Check each rule in order\n      for (const rule of rules) {\n        if (rule.enabled && matchesCondition(value, rule.condition)) {\n          const ruleStyles = styleToCss(rule.styling);\n          // Only return styles if there are actually some set\n          return Object.keys(ruleStyles).length > 0 ? ruleStyles : undefined;\n        }\n      }\n      \n      // Fallback to default styling - only if there are actually some styles set\n      const fallbackStyles = styleToCss(defaultFallback.styling);\n      return Object.keys(fallbackStyles).length > 0 ? fallbackStyles : undefined;\n    };\n  };\n\n     // Generate Excel-style format string with extended styling syntax\n   const generateExcelFormatString = (): string => {\n     if (rules.length === 0) {\n       return '@'; // Default: show original value\n     }\n\n     const sections: string[] = [];\n     \n     // Process each rule to create format sections\n     rules.forEach((rule, _index) => {\n       if (!rule.enabled) return;\n       \n       let section = '';\n       \n       // Add condition\n       switch (rule.condition.type) {\n         case 'equals':\n           // For exact matches, we'll use positive/negative/zero format\n           if (!isNaN(Number(rule.condition.value))) {\n             const num = Number(rule.condition.value);\n             if (num > 0) section += '[>0]';\n             else if (num < 0) section += '[<0]';\n             else section += '[=0]';\n           } else {\n             section += `[=\"${rule.condition.value}\"]`;\n           }\n           break;\n         case 'greaterThan':\n           section += `[>${rule.condition.value}]`;\n           break;\n         case 'lessThan':\n           section += `[<${rule.condition.value}]`;\n           break;\n         case 'greaterEqual':\n           section += `[>=${rule.condition.value}]`;\n           break;\n         case 'lessEqual':\n           section += `[<=${rule.condition.value}]`;\n           break;\n         case 'between':\n           section += `[>=${rule.condition.value}][<=${rule.condition.value2 || rule.condition.value}]`;\n           break;\n         case 'isEmpty':\n           section += '[@=\"\"]';\n           break;\n         case 'isNotEmpty':\n           section += '[<>\"\"]';\n           break;\n         case 'contains':\n           section += `[=\"*${rule.condition.value}*\"]`;\n           break;\n         case 'startsWith':\n           section += `[=\"${rule.condition.value}*\"]`;\n           break;\n         case 'endsWith':\n           section += `[=\"*${rule.condition.value}\"]`;\n           break;\n         default:\n           // For text conditions, we'll create a text-based format\n           section += `[=\"${rule.condition.value}\"]`;\n       }\n       \n       // Add extended styling directives - only for explicitly set properties\n       \n       // Text color - only if explicitly set\n       if (rule.styling.textColor !== undefined) {\n         const colorName = getColorName(rule.styling.textColor);\n         if (colorName) {\n           section += `[${colorName}]`;\n         } else {\n           section += `[${rule.styling.textColor}]`;\n         }\n       }\n       \n       // Background color - only if explicitly set\n       if (rule.styling.backgroundColor !== undefined) {\n         section += `[BG:${rule.styling.backgroundColor}]`;\n       }\n       \n       // Font size - only if explicitly set\n       if (rule.styling.fontSize !== undefined) {\n         section += `[Size:${rule.styling.fontSize}]`;\n       }\n       \n       // Font weight - only if explicitly set\n       if (rule.styling.fontWeight !== undefined) {\n         if (rule.styling.fontWeight === 'bold' || rule.styling.fontWeight === '700') {\n           section += '[Bold]';\n         } else {\n           section += `[Weight:${rule.styling.fontWeight}]`;\n         }\n       }\n       \n       // Font style - only if explicitly set\n       if (rule.styling.fontStyle !== undefined && rule.styling.fontStyle === 'italic') {\n         section += '[Italic]';\n       }\n       \n       // Text decoration - only if explicitly set\n       if (rule.styling.textDecoration !== undefined) {\n         if (rule.styling.textDecoration === 'underline') {\n           section += '[Underline]';\n         } else if (rule.styling.textDecoration === 'line-through') {\n           section += '[Strikethrough]';\n         }\n       }\n       \n       // Text alignment - only if explicitly set\n       if (rule.styling.textAlign !== undefined) {\n         if (rule.styling.textAlign === 'center') {\n           section += '[Center]';\n         } else if (rule.styling.textAlign === 'right') {\n           section += '[Right]';\n         } else if (rule.styling.textAlign === 'left') {\n           section += '[Left]';\n         }\n       }\n       \n       // Border - only if explicitly set (width > 0 and at least one side enabled)\n       if (rule.styling.border && rule.styling.border.width > 0 && (rule.styling.border.sides.top || rule.styling.border.sides.right || rule.styling.border.sides.bottom || rule.styling.border.sides.left)) {\n         const { width, style, color, sides } = rule.styling.border;\n         \n         // Check if all sides are enabled (full border)\n         const allSides = sides.top && sides.right && sides.bottom && sides.left;\n         \n         if (allSides) {\n           section += `[Border:${width}px-${style}-${color}]`;\n         } else {\n           // For individual sides, we'll use a simplified notation\n           const activeSides = [];\n           if (sides.top) activeSides.push('top');\n           if (sides.right) activeSides.push('right');  \n           if (sides.bottom) activeSides.push('bottom');\n           if (sides.left) activeSides.push('left');\n           section += `[Border:${width}px-${style}-${color}-${activeSides.join('+')}]`;\n         }\n       }\n       \n       // Padding - only if explicitly set (any side > 0)\n       if (rule.styling.padding && (rule.styling.padding.top > 0 || rule.styling.padding.right > 0 || rule.styling.padding.bottom > 0 || rule.styling.padding.left > 0)) {\n         const { top, right, bottom, left } = rule.styling.padding;\n         \n         if (top === right && right === bottom && bottom === left) {\n           // All sides same\n           section += `[P:${top}px]`;\n         } else if (top === bottom && left === right) {\n           // Vertical/horizontal same\n           section += `[P:${top}px-${left}px]`;\n         } else {\n           // All different\n           section += `[P:${top}px-${right}px-${bottom}px-${left}px]`;\n         }\n       }\n       \n       // Add display format\n       if (rule.display.type === 'custom') {\n         section += `\"${rule.display.text}\"`;\n       } else {\n         // Determine number format based on column type and value\n         if (columnType === 'number') {\n           section += '#,##0.00';\n         } else {\n           section += '@'; // Text format\n         }\n       }\n       \n       sections.push(section);\n     });\n     \n     // Add default fallback\n     if (defaultFallback.display.type === 'text') {\n       sections.push(`\"${defaultFallback.display.text}\"`);\n     } else {\n       sections.push('@'); // Show original value\n     }\n     \n     return sections.join(';') || '@';\n   };\n\n   // Helper function to get color names for Excel format\n   const getColorName = (hexColor: string): string | null => {\n     const colorMap: Record<string, string> = {\n       '#ff0000': 'Red',\n       '#00ff00': 'Green', \n       '#0000ff': 'Blue',\n       '#ffff00': 'Yellow',\n       '#ff00ff': 'Magenta',\n       '#00ffff': 'Cyan',\n       '#000000': 'Black',\n       '#ffffff': 'White',\n       '#16a34a': 'Green',\n       '#dc2626': 'Red',\n       '#2563eb': 'Blue',\n       '#ca8a04': 'Yellow'\n     };\n     return colorMap[hexColor.toLowerCase()] || null;\n   };\n\n   // Generate readable formatter code for display\n   const generateFormatterCode = (): string => {\n     if (rules.length === 0) {\n       return `(params) => {\n   // No rules defined - return original value\n   return String(params.value || '');\n }`;\n     }\n\n     const conditions = rules.map((rule, index) => {\n       if (!rule.enabled) return `  // Rule ${index + 1} (disabled)`;\n       \n       let conditionCheck = '';\n       const value = rule.condition.value;\n       const value2 = rule.condition.value2;\n       \n       switch (rule.condition.type) {\n         case 'equals':\n           conditionCheck = `String(value) === '${value}'`;\n           break;\n         case 'contains':\n           conditionCheck = `String(value).toLowerCase().includes('${value.toLowerCase()}')`;\n           break;\n         case 'startsWith':\n           conditionCheck = `String(value).toLowerCase().startsWith('${value.toLowerCase()}')`;\n           break;\n         case 'endsWith':\n           conditionCheck = `String(value).toLowerCase().endsWith('${value.toLowerCase()}')`;\n           break;\n         case 'greaterThan':\n           conditionCheck = `Number(value) > ${value}`;\n           break;\n         case 'lessThan':\n           conditionCheck = `Number(value) < ${value}`;\n           break;\n         case 'greaterEqual':\n           conditionCheck = `Number(value) >= ${value}`;\n           break;\n         case 'lessEqual':\n           conditionCheck = `Number(value) <= ${value}`;\n           break;\n         case 'between':\n           conditionCheck = `Number(value) >= ${value} && Number(value) <= ${value2 || value}`;\n           break;\n         case 'isEmpty':\n           conditionCheck = `String(value) === ''`;\n           break;\n         case 'isNotEmpty':\n           conditionCheck = `String(value) !== ''`;\n           break;\n       }\n       \n       const returnValue = rule.display.type === 'custom' \n         ? `'${rule.display.text}'` \n         : 'String(value)';\n       \n       return `  if (${conditionCheck}) {\n     return ${returnValue}; // Rule ${index + 1}\n   }`;\n     }).filter(Boolean).join('\\n');\n\n     const fallbackReturn = defaultFallback.display.type === 'text' \n       ? `'${defaultFallback.display.text}'`\n       : 'String(value || \\'\\')';\n\n     return `(params) => {\n   const value = params.value;\n   \n ${conditions}\n   \n   // Default fallback\n   return ${fallbackReturn};\n }`;\n   };\n\n   // Generate readable cell style code for display\n   const generateCellStyleCode = (): string => {\n     if (rules.length === 0) {\n       return `(params) => {\n   // No styling rules defined\n   return ${JSON.stringify(styleToCss(defaultFallback.styling), null, 2)};\n }`;\n     }\n\n     const conditions = rules.map((rule, index) => {\n       if (!rule.enabled) return `  // Rule ${index + 1} (disabled)`;\n       \n       let conditionCheck = '';\n       const value = rule.condition.value;\n       const value2 = rule.condition.value2;\n       \n       switch (rule.condition.type) {\n         case 'equals':\n           conditionCheck = `String(value) === '${value}'`;\n           break;\n         case 'contains':\n           conditionCheck = `String(value).toLowerCase().includes('${value.toLowerCase()}')`;\n           break;\n         case 'greaterThan':\n           conditionCheck = `Number(value) > ${value}`;\n           break;\n         case 'lessThan':\n           conditionCheck = `Number(value) < ${value}`;\n           break;\n         case 'between':\n           conditionCheck = `Number(value) >= ${value} && Number(value) <= ${value2 || value}`;\n           break;\n         case 'isEmpty':\n           conditionCheck = `String(value) === ''`;\n           break;\n         case 'isNotEmpty':\n           conditionCheck = `String(value) !== ''`;\n           break;\n         default:\n           conditionCheck = `String(value) === '${value}'`;\n       }\n       \n       const styles = styleToCss(rule.styling);\n       const styleString = JSON.stringify(styles, null, 4).replace(/\\n/g, '\\n     ');\n       \n       return `  if (${conditionCheck}) {\n     return ${styleString}; // Rule ${index + 1}\n   }`;\n     }).filter(Boolean).join('\\n');\n\n     const fallbackStyles = styleToCss(defaultFallback.styling);\n     const fallbackStyleString = JSON.stringify(fallbackStyles, null, 2);\n\n     return `(params) => {\n   const value = params.value;\n   \n ${conditions}\n   \n   // Default fallback\n   return ${fallbackStyleString};\n }`;\n   };\n\n   // Preview data with applied formatting\n   const previewData = useMemo(() => {\n     const sampleValues = SAMPLE_DATA[columnType] || SAMPLE_DATA.text;\n     const formatter = generateFormatter();\n     const styleFunc = generateCellStyle();\n     \n     return sampleValues.map(value => ({\n       original: value,\n       formatted: formatter({ value }),\n       style: styleFunc({ value })\n     }));\n   }, [rules, defaultFallback, generateFormatter, generateCellStyle]);\n\n     const handleSave = () => {\n     const formatter = generateFormatter();\n     const cellStyle = generateCellStyle();\n     const excelFormatString = generateExcelFormatString();\n     \n     // Attach Excel format string metadata to the formatter\n     Object.defineProperty(formatter, '__formatString', { \n       value: excelFormatString, \n       writable: false,\n       enumerable: false,\n       configurable: true\n     });\n     \n     // Attach formatter type metadata\n     Object.defineProperty(formatter, '__formatterType', { \n       value: 'visual', \n       writable: false,\n       enumerable: false,\n       configurable: true\n     });\n     \n     // Attach visual editor metadata for full round-trip editing\n     Object.defineProperty(formatter, '__visualRules', { \n       value: rules, \n       writable: false,\n       enumerable: false,\n       configurable: true\n     });\n     \n     Object.defineProperty(formatter, '__visualDefaultFallback', { \n       value: defaultFallback, \n       writable: false,\n       enumerable: false,\n       configurable: true\n     });\n     \n     console.log('[ValueFormatterEditor] Generated formatter with metadata:', {\n       formatString: excelFormatString,\n       rulesCount: rules.length,\n       hasDefaultFallback: !!defaultFallback,\n       cellStyleType: typeof cellStyle,\n       testCellStyle: cellStyle({ value: 'test' })\n     });\n     \n     onSave(formatter, cellStyle);\n     onOpenChange(false);\n   };\n\n   // Copy to clipboard functions\n   const copyFormatterCode = async () => {\n     try {\n       await navigator.clipboard.writeText(generateFormatterCode());\n       setCopiedFormatter(true);\n       setTimeout(() => setCopiedFormatter(false), 2000);\n     } catch (err) {\n       console.error('Failed to copy formatter code:', err);\n     }\n   };\n\n   const copyCellStyleCode = async () => {\n     try {\n       await navigator.clipboard.writeText(generateCellStyleCode());\n       setCopiedCellStyle(true);\n       setTimeout(() => setCopiedCellStyle(false), 2000);\n     } catch (err) {\n       console.error('Failed to copy cell style code:', err);\n     }\n   };\n\n   const copyExcelFormat = async () => {\n     try {\n       await navigator.clipboard.writeText(generateExcelFormatString());\n       setCopiedExcel(true);\n       setTimeout(() => setCopiedExcel(false), 2000);\n     } catch (err) {\n       console.error('Failed to copy Excel format:', err);\n     }\n   };\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"max-w-7xl h-[800px] p-0 flex flex-col\">\n        <DialogHeader className=\"px-6 py-4 border-b\">\n          <DialogTitle className=\"flex items-center gap-2\">\n            <Palette className=\"h-5 w-5\" />\n            {title} - Conditional Formatter Builder\n          </DialogTitle>\n        </DialogHeader>\n\n        <div className=\"flex gap-4 h-full overflow-hidden\">\n          {/* Rules Panel */}\n          <div className=\"flex-1 flex flex-col\">\n            <div className=\"p-4 border-b bg-muted/30\">\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <h3 className=\"font-semibold\">Formatting Rules</h3>\n                  <p className=\"text-sm text-muted-foreground\">Rules are applied in order. First matching rule wins.</p>\n                </div>\n                <Button onClick={addRule} size=\"sm\" className=\"gap-2\">\n                  <Plus className=\"h-4 w-4\" />\n                  Add Rule\n                </Button>\n              </div>\n            </div>\n\n            <ScrollArea className=\"flex-1\">\n              <div className=\"p-4 space-y-4\">\n                {rules.map((rule, index) => (\n                  <RuleEditor\n                    key={rule.id}\n                    rule={rule}\n                    index={index}\n                    totalRules={rules.length}\n                    onUpdate={(updates) => updateRule(rule.id, updates)}\n                    onDelete={() => deleteRule(rule.id)}\n                    onMove={(direction) => moveRule(rule.id, direction)}\n                    columnType={columnType}\n                  />\n                ))}\n\n                {/* Default Fallback */}\n                <Card className=\"border-dashed\">\n                  <CardHeader className=\"pb-3\">\n                    <CardTitle className=\"text-sm flex items-center gap-2\">\n                      <Settings className=\"h-4 w-4\" />\n                      Default (Fallback)\n                    </CardTitle>\n                    <CardDescription className=\"text-xs\">\n                      Applied when no rules match\n                    </CardDescription>\n                  </CardHeader>\n                  <CardContent>\n                    <div className=\"space-y-4\">\n                      <div className=\"space-y-2\">\n                        <Label className=\"text-xs\">Display</Label>\n                        <Select\n                          value={defaultFallback.display.type}\n                          onValueChange={(value: 'original' | 'text') => \n                            setDefaultFallback(prev => ({\n                              ...prev,\n                              display: { ...prev.display, type: value }\n                            }))\n                          }\n                        >\n                          <SelectTrigger className=\"h-8\">\n                            <SelectValue />\n                          </SelectTrigger>\n                          <SelectContent>\n                            <SelectItem value=\"original\">Show Original Value</SelectItem>\n                            <SelectItem value=\"text\">Custom Text</SelectItem>\n                          </SelectContent>\n                        </Select>\n                        {defaultFallback.display.type === 'text' && (\n                          <Input\n                            placeholder=\"Default text\"\n                            value={defaultFallback.display.text}\n                            onChange={(e) => \n                              setDefaultFallback(prev => ({\n                                ...prev,\n                                display: { ...prev.display, text: e.target.value }\n                              }))\n                            }\n                            className=\"h-8\"\n                          />\n                        )}\n                      </div>\n                    </div>\n                  </CardContent>\n                </Card>\n              </div>\n            </ScrollArea>\n          </div>\n\n          {/* Preview Panel */}\n          <div className=\"w-[350px] border-l bg-muted/30 flex flex-col\">\n            <div className=\"p-4 border-b\">\n              <h3 className=\"font-semibold flex items-center gap-2\">\n                <Eye className=\"h-4 w-4\" />\n                Live Preview\n              </h3>\n              <p className=\"text-sm text-muted-foreground\">\n                See how your rules will look with sample data\n              </p>\n            </div>\n            \n                         <ScrollArea className=\"flex-1 p-4\">\n               <div className=\"space-y-4\">\n                 {/* Live Preview Section */}\n                 <div className=\"space-y-3\">\n                   {previewData.map((item, index) => (\n                     <div key={index} className=\"space-y-1\">\n                       <div className=\"text-xs text-muted-foreground\">\n                         Input: <code className=\"bg-background px-1 py-0.5 rounded\">{JSON.stringify(item.original)}</code>\n                       </div>\n                       <div \n                         className=\"p-3 rounded border text-sm font-medium min-h-[40px] flex items-center\"\n                         style={item.style}\n                       >\n                         {item.formatted}\n                       </div>\n                     </div>\n                   ))}\n                 </div>\n\n                 <Separator />\n\n                 {/* Generated Code Section */}\n                 <div className=\"space-y-2\">\n                   <div className=\"flex items-center gap-2\">\n                     <Settings className=\"h-4 w-4\" />\n                     <h4 className=\"font-semibold text-sm\">Generated Code</h4>\n                   </div>\n                   \n                                        <Tabs defaultValue=\"excel\" className=\"w-full\">\n                     <TabsList className=\"grid w-full grid-cols-3\">\n                       <TabsTrigger value=\"excel\" className=\"text-xs\">Excel Format</TabsTrigger>\n                       <TabsTrigger value=\"formatter\" className=\"text-xs\">JavaScript</TabsTrigger>\n                       <TabsTrigger value=\"cellStyle\" className=\"text-xs\">Cell Style</TabsTrigger>\n                     </TabsList>\n                     \n                     <TabsContent value=\"excel\" className=\"mt-2\">\n                       <div className=\"bg-muted/50 rounded border\">\n                         <div className=\"flex items-center justify-between p-2 border-b\">\n                           <span className=\"text-xs font-medium\">Excel Format String</span>\n                           <Button\n                             variant=\"ghost\"\n                             size=\"sm\"\n                             onClick={copyExcelFormat}\n                             className=\"h-6 px-2 gap-1\"\n                           >\n                             {copiedExcel ? (\n                               <>\n                                 <Check className=\"h-3 w-3 text-green-600\" />\n                                 <span className=\"text-xs text-green-600\">Copied!</span>\n                               </>\n                             ) : (\n                               <>\n                                 <Copy className=\"h-3 w-3\" />\n                                 <span className=\"text-xs\">Copy</span>\n                               </>\n                             )}\n                           </Button>\n                         </div>\n                         <div className=\"p-3\">\n                           <div className=\"bg-background p-2 rounded border mb-2\">\n                             <code className=\"text-sm font-mono text-foreground break-all\">\n                               {generateExcelFormatString()}\n                             </code>\n                           </div>\n                           <div className=\"text-xs text-muted-foreground\">\n                             This Excel-style format string can be used with ag-grid's valueFormatter or in Excel/Google Sheets.\n                           </div>\n                         </div>\n                       </div>\n                     </TabsContent>\n                     \n                     <TabsContent value=\"formatter\" className=\"mt-2\">\n                       <div className=\"bg-muted/50 rounded border\">\n                         <div className=\"flex items-center justify-between p-2 border-b\">\n                           <span className=\"text-xs font-medium\">Value Formatter Function</span>\n                           <Button\n                             variant=\"ghost\"\n                             size=\"sm\"\n                             onClick={copyFormatterCode}\n                             className=\"h-6 px-2 gap-1\"\n                           >\n                             {copiedFormatter ? (\n                               <>\n                                 <Check className=\"h-3 w-3 text-green-600\" />\n                                 <span className=\"text-xs text-green-600\">Copied!</span>\n                               </>\n                             ) : (\n                               <>\n                                 <Copy className=\"h-3 w-3\" />\n                                 <span className=\"text-xs\">Copy</span>\n                               </>\n                             )}\n                           </Button>\n                         </div>\n                         <div className=\"p-3\">\n                           <pre className=\"text-xs font-mono text-muted-foreground whitespace-pre-wrap overflow-auto max-h-[200px]\">\n                             {generateFormatterCode()}\n                           </pre>\n                         </div>\n                       </div>\n                     </TabsContent>\n                     \n                     <TabsContent value=\"cellStyle\" className=\"mt-2\">\n                       <div className=\"bg-muted/50 rounded border\">\n                         <div className=\"flex items-center justify-between p-2 border-b\">\n                           <span className=\"text-xs font-medium\">Cell Style Function</span>\n                           <Button\n                             variant=\"ghost\"\n                             size=\"sm\"\n                             onClick={copyCellStyleCode}\n                             className=\"h-6 px-2 gap-1\"\n                           >\n                             {copiedCellStyle ? (\n                               <>\n                                 <Check className=\"h-3 w-3 text-green-600\" />\n                                 <span className=\"text-xs text-green-600\">Copied!</span>\n                               </>\n                             ) : (\n                               <>\n                                 <Copy className=\"h-3 w-3\" />\n                                 <span className=\"text-xs\">Copy</span>\n                               </>\n                             )}\n                           </Button>\n                         </div>\n                         <div className=\"p-3\">\n                           <pre className=\"text-xs font-mono text-muted-foreground whitespace-pre-wrap overflow-auto max-h-[200px]\">\n                             {generateCellStyleCode()}\n                           </pre>\n                         </div>\n                       </div>\n                     </TabsContent>\n                   </Tabs>\n\n                   {/* Rules Summary */}\n                   <div className=\"mt-3 p-2 bg-background rounded border\">\n                     <div className=\"text-xs font-medium mb-1\">Rules Summary:</div>\n                     {rules.length === 0 ? (\n                       <div className=\"text-xs text-muted-foreground italic\">No rules defined</div>\n                     ) : (\n                       <div className=\"space-y-1\">\n                         {rules.map((rule, index) => (\n                           <div key={rule.id} className=\"text-xs\">\n                             <span className={`font-medium ${rule.enabled ? 'text-foreground' : 'text-muted-foreground'}`}>\n                               Rule {index + 1}:\n                             </span>\n                             <span className=\"text-muted-foreground ml-1\">\n                               {rule.condition.type} \"{rule.condition.value}\"\n                               {rule.condition.value2 && ` and \"${rule.condition.value2}\"`}\n                               → \"{rule.display.text || 'original'}\"\n                               {!rule.enabled && ' (disabled)'}\n                             </span>\n                           </div>\n                         ))}\n                       </div>\n                     )}\n                   </div>\n                 </div>\n               </div>\n             </ScrollArea>\n          </div>\n        </div>\n\n        <DialogFooter className=\"px-6 py-4 border-t\">\n          <Button variant=\"outline\" onClick={() => onOpenChange(false)}>\n            Cancel\n          </Button>\n          <Button onClick={handleSave}>\n            Apply Formatting Rules\n          </Button>\n        </DialogFooter>\n      </DialogContent>\n    </Dialog>\n  );\n};\n\n// Individual Rule Editor Component\ninterface RuleEditorProps {\n  rule: FormattingRule;\n  index: number;\n  totalRules: number;\n  onUpdate: (updates: Partial<FormattingRule>) => void;\n  onDelete: () => void;\n  onMove: (direction: 'up' | 'down') => void;\n  columnType: string;\n}\n\nconst RuleEditor: React.FC<RuleEditorProps> = ({\n  rule,\n  index,\n  totalRules,\n  onUpdate,\n  onDelete,\n  onMove,\n  columnType: _columnType\n}) => {\n  const conditionOption = CONDITION_OPTIONS.find(opt => opt.value === rule.condition.type);\n\n  return (\n    <Card className={rule.enabled ? '' : 'opacity-50'}>\n      <CardHeader className=\"pb-3\">\n        <div className=\"flex items-center justify-between\">\n          <CardTitle className=\"text-sm flex items-center gap-2\">\n            Rule {index + 1}\n            <Switch\n              checked={rule.enabled}\n              onCheckedChange={(enabled) => onUpdate({ enabled })}\n            />\n          </CardTitle>\n          <div className=\"flex items-center gap-1\">\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={() => onMove('up')}\n              disabled={index === 0}\n              className=\"h-7 w-7 p-0\"\n            >\n              <ArrowUp className=\"h-3 w-3\" />\n            </Button>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={() => onMove('down')}\n              disabled={index === totalRules - 1}\n              className=\"h-7 w-7 p-0\"\n            >\n              <ArrowDown className=\"h-3 w-3\" />\n            </Button>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={onDelete}\n              className=\"h-7 w-7 p-0 text-destructive hover:text-destructive\"\n            >\n              <Trash2 className=\"h-3 w-3\" />\n            </Button>\n          </div>\n        </div>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        <Tabs defaultValue=\"condition\" className=\"w-full\">\n          <TabsList className=\"grid w-full grid-cols-3\">\n            <TabsTrigger value=\"condition\" className=\"text-xs\">Condition</TabsTrigger>\n            <TabsTrigger value=\"display\" className=\"text-xs\">Display</TabsTrigger>\n            <TabsTrigger value=\"styling\" className=\"text-xs\">Styling</TabsTrigger>\n          </TabsList>\n          \n          <TabsContent value=\"condition\" className=\"space-y-3 mt-3\">\n            <div className=\"space-y-2\">\n              <Label className=\"text-xs\">When value</Label>\n              <Select\n                value={rule.condition.type}\n                onValueChange={(value: FormattingRule['condition']['type']) =>\n                  onUpdate({\n                    condition: { ...rule.condition, type: value }\n                  })\n                }\n              >\n                <SelectTrigger className=\"h-8\">\n                  <SelectValue />\n                </SelectTrigger>\n                <SelectContent>\n                  {CONDITION_OPTIONS.map(option => (\n                    <SelectItem key={option.value} value={option.value}>\n                      {option.label}\n                    </SelectItem>\n                  ))}\n                </SelectContent>\n              </Select>\n            </div>\n            \n            {conditionOption?.needsValue && (\n              <div className=\"space-y-2\">\n                <Label className=\"text-xs\">Value</Label>\n                <Input\n                  placeholder=\"Enter value\"\n                  value={rule.condition.value}\n                  onChange={(e) =>\n                    onUpdate({\n                      condition: { ...rule.condition, value: e.target.value }\n                    })\n                  }\n                  className=\"h-8\"\n                />\n              </div>\n            )}\n            \n            {conditionOption?.needsValue2 && (\n              <div className=\"space-y-2\">\n                <Label className=\"text-xs\">And</Label>\n                <Input\n                  placeholder=\"Enter second value\"\n                  value={rule.condition.value2 || ''}\n                  onChange={(e) =>\n                    onUpdate({\n                      condition: { ...rule.condition, value2: e.target.value }\n                    })\n                  }\n                  className=\"h-8\"\n                />\n              </div>\n            )}\n          </TabsContent>\n          \n          <TabsContent value=\"display\" className=\"space-y-3 mt-3\">\n            <div className=\"space-y-2\">\n              <Label className=\"text-xs\">Display as</Label>\n              <Select\n                value={rule.display.type}\n                onValueChange={(value: FormattingRule['display']['type']) =>\n                  onUpdate({\n                    display: { ...rule.display, type: value }\n                  })\n                }\n              >\n                <SelectTrigger className=\"h-8\">\n                  <SelectValue />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"original\">Original Value</SelectItem>\n                  <SelectItem value=\"custom\">Custom Text</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n            \n            {rule.display.type === 'custom' && (\n              <div className=\"space-y-2\">\n                <Label className=\"text-xs\">Custom Text</Label>\n                <Input\n                  placeholder=\"e.g., Option 1\"\n                  value={rule.display.text}\n                  onChange={(e) =>\n                    onUpdate({\n                      display: { ...rule.display, text: e.target.value }\n                    })\n                  }\n                  className=\"h-8\"\n                />\n              </div>\n            )}\n          </TabsContent>\n          \n          <TabsContent value=\"styling\" className=\"space-y-3 mt-3\">\n            <div className=\"grid grid-cols-2 gap-3\">\n              <div className=\"space-y-2\">\n                <Label className=\"text-xs\">Background</Label>\n                <div className=\"flex gap-2\">\n                  <Input\n                    type=\"color\"\n                    value={rule.styling.backgroundColor}\n                    onChange={(e) =>\n                      onUpdate({\n                        styling: { ...rule.styling, backgroundColor: e.target.value }\n                      })\n                    }\n                    className=\"h-8 w-16 p-1\"\n                  />\n                  <Input\n                    value={rule.styling.backgroundColor}\n                    onChange={(e) =>\n                      onUpdate({\n                        styling: { ...rule.styling, backgroundColor: e.target.value }\n                      })\n                    }\n                    className=\"h-8 flex-1 font-mono text-xs\"\n                  />\n                </div>\n              </div>\n              \n              <div className=\"space-y-2\">\n                <Label className=\"text-xs\">Text Color</Label>\n                <div className=\"flex gap-2\">\n                  <Input\n                    type=\"color\"\n                    value={rule.styling.textColor}\n                    onChange={(e) =>\n                      onUpdate({\n                        styling: { ...rule.styling, textColor: e.target.value }\n                      })\n                    }\n                    className=\"h-8 w-16 p-1\"\n                  />\n                  <Input\n                    value={rule.styling.textColor}\n                    onChange={(e) =>\n                      onUpdate({\n                        styling: { ...rule.styling, textColor: e.target.value }\n                      })\n                    }\n                    className=\"h-8 flex-1 font-mono text-xs\"\n                  />\n                </div>\n              </div>\n              \n              <div className=\"space-y-2\">\n                <Label className=\"text-xs\">Font Weight</Label>\n                <Select\n                  value={rule.styling.fontWeight}\n                  onValueChange={(value: FormattingRule['styling']['fontWeight']) =>\n                    onUpdate({\n                      styling: { ...rule.styling, fontWeight: value }\n                    })\n                  }\n                >\n                  <SelectTrigger className=\"h-8\">\n                    <SelectValue />\n                  </SelectTrigger>\n                  <SelectContent>\n                    <SelectItem value=\"normal\">Normal</SelectItem>\n                    <SelectItem value=\"bold\">Bold</SelectItem>\n                    <SelectItem value=\"100\">100</SelectItem>\n                    <SelectItem value=\"200\">200</SelectItem>\n                    <SelectItem value=\"300\">300</SelectItem>\n                    <SelectItem value=\"400\">400</SelectItem>\n                    <SelectItem value=\"500\">500</SelectItem>\n                    <SelectItem value=\"600\">600</SelectItem>\n                    <SelectItem value=\"700\">700</SelectItem>\n                    <SelectItem value=\"800\">800</SelectItem>\n                    <SelectItem value=\"900\">900</SelectItem>\n                  </SelectContent>\n                </Select>\n              </div>\n              \n              <div className=\"space-y-2\">\n                <Label className=\"text-xs\">Font Size</Label>\n                <Input\n                  type=\"number\"\n                  value={rule.styling.fontSize || 14}\n                  onChange={(e) =>\n                    onUpdate({\n                      styling: { ...rule.styling, fontSize: Number(e.target.value) }\n                    })\n                  }\n                  className=\"h-8\"\n                  min={8}\n                  max={72}\n                />\n              </div>\n            </div>\n            \n            {/* Border Settings */}\n            <div className=\"space-y-2\">\n              <Label className=\"text-xs\">Border</Label>\n              <div className=\"grid grid-cols-3 gap-2\">\n                <div className=\"space-y-1\">\n                  <Label className=\"text-xs text-muted-foreground\">Width</Label>\n                  <Input\n                    type=\"number\"\n                    value={rule.styling.border?.width || 0}\n                    onChange={(e) =>\n                      onUpdate({\n                        styling: {\n                          ...rule.styling,\n                          border: {\n                            ...rule.styling.border!,\n                            width: Number(e.target.value)\n                          }\n                        }\n                      })\n                    }\n                    className=\"h-7\"\n                    min={0}\n                    max={10}\n                  />\n                </div>\n                <div className=\"space-y-1\">\n                  <Label className=\"text-xs text-muted-foreground\">Style</Label>\n                  <Select\n                    value={rule.styling.border?.style || 'solid'}\n                    onValueChange={(value: 'solid' | 'dashed' | 'dotted' | 'double') =>\n                      onUpdate({\n                        styling: {\n                          ...rule.styling,\n                          border: {\n                            ...rule.styling.border!,\n                            style: value\n                          }\n                        }\n                      })\n                    }\n                  >\n                    <SelectTrigger className=\"h-7\">\n                      <SelectValue />\n                    </SelectTrigger>\n                    <SelectContent>\n                      <SelectItem value=\"solid\">Solid</SelectItem>\n                      <SelectItem value=\"dashed\">Dashed</SelectItem>\n                      <SelectItem value=\"dotted\">Dotted</SelectItem>\n                      <SelectItem value=\"double\">Double</SelectItem>\n                    </SelectContent>\n                  </Select>\n                </div>\n                <div className=\"space-y-1\">\n                  <Label className=\"text-xs text-muted-foreground\">Color</Label>\n                  <Input\n                    type=\"color\"\n                    value={rule.styling.border?.color || '#000000'}\n                    onChange={(e) =>\n                      onUpdate({\n                        styling: {\n                          ...rule.styling,\n                          border: {\n                            ...rule.styling.border!,\n                            color: e.target.value\n                          }\n                        }\n                      })\n                    }\n                    className=\"h-7 p-1\"\n                  />\n                </div>\n              </div>\n              \n              {/* Border Sides */}\n              {(rule.styling.border?.width || 0) > 0 && (\n                <div className=\"flex items-center gap-4 text-xs\">\n                  <Label className=\"text-muted-foreground\">Sides:</Label>\n                  {[\n                    { key: 'top', label: 'Top' },\n                    { key: 'right', label: 'Right' },\n                    { key: 'bottom', label: 'Bottom' },\n                    { key: 'left', label: 'Left' }\n                  ].map(side => (\n                    <label key={side.key} className=\"flex items-center gap-1 cursor-pointer\">\n                      <input\n                        type=\"checkbox\"\n                        checked={rule.styling.border?.sides[side.key as keyof typeof rule.styling.border.sides] || false}\n                        onChange={(e) =>\n                          onUpdate({\n                            styling: {\n                              ...rule.styling,\n                              border: {\n                                ...rule.styling.border!,\n                                sides: {\n                                  ...rule.styling.border!.sides,\n                                  [side.key]: e.target.checked\n                                }\n                              }\n                            }\n                          })\n                        }\n                        className=\"w-3 h-3\"\n                      />\n                      {side.label}\n                    </label>\n                  ))}\n                </div>\n              )}\n            </div>\n          </TabsContent>\n        </Tabs>\n      </CardContent>\n    </Card>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/hooks/useOptimizedStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/hooks/useSoundPreference.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/panels/BulkActionsPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":225,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":225,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6639,6642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6639,6642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useCallback, useState, useEffect } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { Input } from '@/components/ui/input';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from '@/components/ui/dialog';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { useColumnCustomizationStore } from '../store/columnCustomization.store';\nimport { ColDef, ValueFormatterParams } from 'ag-grid-community';\nimport {\n  Copy,\n  Eraser,\n  Save,\n  Trash2,\n  AlertCircle,\n  Edit2,\n  Sparkles\n} from 'lucide-react';\n\n// Template storage key\nconst TEMPLATES_STORAGE_KEY = 'column-customization-templates';\n\n// Template interface\ninterface ColumnTemplate {\n  id: string;\n  name: string;\n  createdAt: number;\n  properties: Partial<ColDef>;\n  isSystem?: boolean; // Flag to identify system templates\n}\n\n// Type for functions with metadata\ntype FunctionWithMetadata = {\n  (params: unknown): unknown;\n  __formatString?: string;\n  __baseStyle?: React.CSSProperties;\n};\n\n// Properties to save in templates - comprehensive list\nconst TEMPLATE_PROPERTIES = [\n  // NOTE: 'field' and 'headerName' are intentionally excluded from templates\n  // They should only be applied to single columns, not in bulk\n  \n  // Data type and basic properties\n  'cellDataType', 'type', 'valueGetter', 'valueSetter',\n  \n  // Filter configurations\n  'filter', 'filterParams', 'floatingFilter', 'floatingFilterComponent', 'floatingFilterComponentParams',\n  'suppressHeaderMenuButton', 'suppressFiltersToolPanel', 'filterValueGetter',\n  \n  // Editor configurations\n  'editable', 'cellEditor', 'cellEditorParams', 'cellEditorPopup', 'cellEditorPopupPosition',\n  'singleClickEdit', 'stopEditingWhenCellsLoseFocus', 'cellEditorSelector',\n  \n  // Renderer configurations\n  'cellRenderer', 'cellRendererParams', 'cellRendererSelector', 'autoHeight', 'wrapText',\n  \n  // Styling and visual properties\n  'cellStyle', 'cellClass', 'cellClassRules',\n  'headerClass', 'headerStyle', 'headerComponent', 'headerComponentParams',\n  'headerTooltip', 'tooltipField', 'tooltipValueGetter', 'tooltipComponent', 'tooltipComponentParams',\n  \n  // Column behavior\n  'hide', 'lockVisible', 'lockPosition', 'suppressMovable',\n  'suppressMenu', 'suppressColumnsToolPanel', 'suppressSizeToFit',\n  \n  // Sizing configurations\n  'width', 'minWidth', 'maxWidth', 'flex', 'resizable', 'suppressAutoSize',\n  'wrapHeaderText', 'autoHeaderHeight',\n  \n  // Sorting configurations\n  'sortable', 'sort', 'sortIndex', 'sortingOrder', 'comparator', 'unSortIcon',\n  \n  // Row grouping and aggregation\n  'rowGroup', 'rowGroupIndex', 'enableRowGroup', 'enablePivot', 'enableValue',\n  'aggFunc', 'allowedAggFuncs', 'pivotIndex', 'pivotComparator',\n  \n  // Pinning configurations\n  'pinned', 'lockPinned',\n  \n  // Cell selection\n  'checkboxSelection', 'showDisabledCheckboxes', 'headerCheckboxSelection',\n  'headerCheckboxSelectionFilteredOnly', 'headerCheckboxSelectionCurrentPageOnly',\n  \n  // Column spanning\n  'colSpan', 'rowSpan',\n  \n  // Value formatting\n  'valueFormatter', 'useValueFormatterForExport',\n  \n  // Quick filter\n  'quickFilterText', 'includeHiddenColumnsInQuickFilter',\n  \n  // Column group properties\n  'children', 'groupId', 'openByDefault', 'marryChildren', 'toolPanelClass',\n  \n  // Menu tabs\n  'menuTabs', 'columnsMenuParams', 'suppressColumnsToolPanel',\n  \n  // Custom metadata (internal)\n  '_hasCustomStyles', '_userModified', '_templateApplied'\n];\n\n// Predefined system templates\nconst SYSTEM_TEMPLATES: ColumnTemplate[] = [\n  {\n    id: 'system-currency',\n    name: 'Currency Format',\n    createdAt: Date.now(),\n    isSystem: true,\n    properties: {\n      valueFormatter: (params: ValueFormatterParams) => {\n        if (params.value == null) return '';\n        return new Intl.NumberFormat('en-US', {\n          style: 'currency',\n          currency: 'USD'\n        }).format(params.value);\n      },\n      cellStyle: { textAlign: 'right', fontWeight: '500' },\n      headerStyle: () => ({ textAlign: 'right', fontWeight: '600' }),\n      type: 'numericColumn'\n    }\n  },\n  {\n    id: 'system-percentage',\n    name: 'Percentage Format',\n    createdAt: Date.now(),\n    isSystem: true,\n    properties: {\n      valueFormatter: (params: ValueFormatterParams) => {\n        if (params.value == null) return '';\n        return `${(params.value * 100).toFixed(2)}%`;\n      },\n      cellStyle: { textAlign: 'right', color: '#059669' },\n      headerStyle: () => ({ textAlign: 'right' }),\n      type: 'numericColumn'\n    }\n  },\n  {\n    id: 'system-date',\n    name: 'Date Format',\n    createdAt: Date.now(),\n    isSystem: true,\n    properties: {\n      valueFormatter: (params: ValueFormatterParams) => {\n        if (!params.value) return '';\n        return new Date(params.value).toLocaleDateString('en-US', {\n          year: 'numeric',\n          month: 'short',\n          day: 'numeric'\n        });\n      },\n      cellStyle: { textAlign: 'center' },\n      headerStyle: () => ({ textAlign: 'center' }),\n      filter: 'agDateColumnFilter'\n    }\n  },\n  {\n    id: 'system-bold-header',\n    name: 'Bold Headers',\n    createdAt: Date.now(),\n    isSystem: true,\n    properties: {\n      headerStyle: () => ({ \n        fontWeight: '700', \n        backgroundColor: '#f8fafc',\n        borderBottom: '2px solid #e2e8f0'\n      }),\n      wrapHeaderText: true,\n      autoHeaderHeight: true\n    }\n  },\n  {\n    id: 'system-center-align',\n    name: 'Center Aligned',\n    createdAt: Date.now(),\n    isSystem: true,\n    properties: {\n      cellStyle: { textAlign: 'center' },\n      headerStyle: () => ({ textAlign: 'center' })\n    }\n  },\n  {\n    id: 'system-highlight',\n    name: 'Highlighted Column',\n    createdAt: Date.now(),\n    isSystem: true,\n    properties: {\n      cellStyle: { \n        backgroundColor: '#fef3c7', \n        borderLeft: '3px solid #f59e0b',\n        fontWeight: '500'\n      },\n      headerStyle: () => ({ \n        backgroundColor: '#fbbf24', \n        color: '#92400e',\n        fontWeight: '600'\n      })\n    }\n  },\n  {\n    id: 'system-compact',\n    name: 'Compact Layout',\n    createdAt: Date.now(),\n    isSystem: true,\n    properties: {\n      cellStyle: { \n        fontSize: '12px', \n        padding: '4px 8px',\n        lineHeight: '1.2'\n      },\n      headerStyle: () => ({ \n        fontSize: '11px', \n        fontWeight: '600',\n        padding: '4px 8px'\n      }),\n      autoHeight: false\n    }\n  },\n  {\n    id: 'system-status',\n    name: 'Status Badges',\n    createdAt: Date.now(),\n    isSystem: true,\n    properties: {\n      cellRenderer: (params: any) => {\n        if (!params.value) return '';\n        const status = params.value.toLowerCase();\n        const colors = {\n          active: '#10b981',\n          inactive: '#6b7280',\n          pending: '#f59e0b',\n          completed: '#3b82f6',\n          error: '#ef4444'\n        };\n        const color = colors[status as keyof typeof colors] || '#6b7280';\n        return `<span style=\"background: ${color}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: 500;\">${params.value}</span>`;\n      },\n      cellStyle: { textAlign: 'center' },\n      headerStyle: () => ({ textAlign: 'center' })\n    }\n  }\n];\n\n// Helper function to get system template descriptions\nconst getSystemTemplateDescription = (templateId: string): string => {\n  const descriptions: Record<string, string> = {\n    'system-currency': 'Formats numbers as currency with right alignment',\n    'system-percentage': 'Displays values as percentages with green color',\n    'system-date': 'Formats dates in readable format with center alignment',\n    'system-bold-header': 'Makes headers bold with enhanced styling',\n    'system-center-align': 'Centers text in both cells and headers',\n    'system-highlight': 'Highlights column with yellow background',\n    'system-compact': 'Reduces font size and padding for compact view',\n    'system-status': 'Renders status values as colored badges'\n  };\n  return descriptions[templateId] || 'System template';\n};\n\nexport const BulkActionsPanel: React.FC = () => {\n  const {\n    selectedColumns,\n    columnDefinitions,\n    pendingChanges,\n    updateBulkProperties,\n    setAppliedTemplate\n  } = useColumnCustomizationStore();\n\n  const [selectedTemplateIds, setSelectedTemplateIds] = useState<string[]>([]);\n  const [userTemplates, setUserTemplates] = useState<ColumnTemplate[]>([]);\n  const [showSaveDialog, setShowSaveDialog] = useState(false);\n  const [showDeleteDialog, setShowDeleteDialog] = useState(false);\n  const [templateName, setTemplateName] = useState('');\n  const [templateToDelete, setTemplateToDelete] = useState<string>('');\n  const [editingTemplateId, setEditingTemplateId] = useState<string>('');\n\n  // Combine system and user templates\n  const templates = useMemo(() => {\n    return [...SYSTEM_TEMPLATES, ...userTemplates];\n  }, [userTemplates]);\n\n  // Load templates from localStorage\n  useEffect(() => {\n    const storedTemplates = localStorage.getItem(TEMPLATES_STORAGE_KEY);\n    if (storedTemplates) {\n      try {\n        setUserTemplates(JSON.parse(storedTemplates));\n      } catch (e) {\n        console.error('Failed to load templates:', e);\n      }\n    }\n  }, []);\n\n  // Save templates to localStorage\n  const saveTemplates = useCallback((newTemplates: ColumnTemplate[]) => {\n    setUserTemplates(newTemplates);\n    localStorage.setItem(TEMPLATES_STORAGE_KEY, JSON.stringify(newTemplates));\n  }, []);\n\n  // Get current column configuration\n  const getCurrentColumnConfig = useCallback(() => {\n    if (selectedColumns.size === 0) return null;\n    \n    // Get the first selected column's configuration\n    const firstColumnId = Array.from(selectedColumns)[0];\n    const columnDef = columnDefinitions.get(firstColumnId);\n    const changes = pendingChanges.get(firstColumnId);\n    \n    if (!columnDef) return null;\n    \n    const config: Partial<ColDef> = {};\n    \n    TEMPLATE_PROPERTIES.forEach(property => {\n      // Check pending changes first, then column definition\n      const value = changes?.[property] ?? columnDef[property as keyof ColDef];\n      if (value !== undefined) {\n        // Special handling for functions - convert to serializable format\n        if (typeof value === 'function') {\n          // For formatters, we just copy the function reference\n          if (property === 'valueFormatter') {\n            // Store the formatter function directly\n            if (value && typeof value === 'function') {\n              config[property] = value;\n            }\n          } else if (property === 'headerStyle') {\n            // Special handling for headerStyle function\n            try {\n              // Extract styles for both regular header and floating filter\n              const regularStyle = value({ floatingFilter: false });\n              const floatingStyle = value({ floatingFilter: true });\n              \n              // Store as an object that preserves the conditional logic\n              config[property] = {\n                _isHeaderStyleConfig: true,\n                regular: regularStyle,\n                floating: floatingStyle\n              };\n            } catch (e) {\n              console.warn(`Failed to extract headerStyle:`, e);\n              // Try to store just the regular style\n              try {\n                const regularStyle = value({});\n                if (regularStyle && typeof regularStyle === 'object') {\n                  config[property] = regularStyle;\n                }\n              } catch (e2) {\n                console.warn(`Failed to extract headerStyle completely:`, e2);\n              }\n            }\n          } else if (property === 'cellStyle') {\n            // Check if this is our conditional formatting function with metadata\n            const fn = value as FunctionWithMetadata;\n            const formatString = fn.__formatString;\n            const baseStyle = fn.__baseStyle;\n            \n            if (formatString) {\n              // Store as a configuration object that can be recreated\n              config[property] = {\n                type: 'function',\n                formatString: formatString,\n                baseStyle: baseStyle\n              };\n            } else {\n              // Extract style by calling the function if it's a function\n              try {\n                const extractedStyle = value({});\n                if (extractedStyle && typeof extractedStyle === 'object') {\n                  config[property] = extractedStyle;\n                }\n              } catch (e) {\n                // If function fails, try to store as is\n                console.warn(`Failed to extract cellStyle:`, e);\n              }\n            }\n          } else if (property === 'comparator' || property === 'valueGetter' || property === 'valueSetter' || \n                     property === 'cellRenderer' || property === 'cellEditor' || property === 'filterValueGetter' ||\n                     property === 'tooltipValueGetter') {\n            // For other functions, store a flag that they exist\n            config[`_has${property.charAt(0).toUpperCase() + property.slice(1)}`] = true;\n          }\n        } else if (value && typeof value === 'object' && property === 'headerStyle' && \n                   value._isHeaderStyleConfig) {\n          // If it's already in our special format, store it as is\n          config[property] = value;\n        } else {\n          // For non-function values, store directly\n          config[property] = value;\n        }\n      }\n    });\n    \n    console.log('[BulkActionsPanel] Template configuration captured:', {\n      columnId: firstColumnId,\n      propertiesFound: Object.keys(config),\n      hasHeaderStyle: !!config.headerStyle,\n      headerStyleType: config.headerStyle ? typeof config.headerStyle : 'none',\n      hasCellStyle: !!config.cellStyle,\n      hasValueFormatter: !!config.valueFormatter,\n      totalProperties: Object.keys(config).length\n    });\n    \n    return config;\n  }, [selectedColumns, columnDefinitions, pendingChanges]);\n\n  // Save current configuration as template\n  const saveAsTemplate = useCallback(() => {\n    const config = getCurrentColumnConfig();\n    if (!config || !templateName.trim()) return;\n    \n    const newTemplate: ColumnTemplate = {\n      id: editingTemplateId || Date.now().toString(),\n      name: templateName.trim(),\n      createdAt: Date.now(),\n      properties: config\n    };\n    \n    let newTemplates: ColumnTemplate[];\n    if (editingTemplateId) {\n      // Update existing template\n      newTemplates = userTemplates.map(t => \n        t.id === editingTemplateId ? newTemplate : t\n      );\n    } else {\n      // Add new template\n      newTemplates = [...userTemplates, newTemplate];\n    }\n    \n    saveTemplates(newTemplates);\n    setShowSaveDialog(false);\n    setTemplateName('');\n    setEditingTemplateId('');\n  }, [getCurrentColumnConfig, templateName, userTemplates, saveTemplates, editingTemplateId]);\n\n  // Apply template to selected columns\n  const applyTemplate = useCallback(() => {\n    if (!selectedTemplateIds.length) return;\n    \n    console.log('[BulkActionsPanel] Applying multiple templates:', {\n      templateIds: selectedTemplateIds,\n      templateNames: selectedTemplateIds.map(id => templates.find(t => t.id === id)?.name).filter(Boolean),\n      selectedColumnsCount: selectedColumns.size\n    });\n    \n    // Merge all selected templates - later templates override earlier ones\n    const mergedProperties: Partial<ColDef> = {};\n    const appliedTemplateNames: string[] = [];\n    \n    selectedTemplateIds.forEach(templateId => {\n      const template = templates.find(t => t.id === templateId);\n      if (!template) return;\n      \n      appliedTemplateNames.push(template.name);\n      \n      // Create a copy of template properties\n      const templateProps = { ...template.properties };\n      \n      // Remove field and headerName to ensure they're never applied from templates\n      delete templateProps.field;\n      delete templateProps.headerName;\n      \n      // Special handling for certain properties\n      \n      // If template has a valueFormatter, apply it directly\n      if (templateProps.valueFormatter && typeof templateProps.valueFormatter === 'function') {\n        mergedProperties.valueFormatter = templateProps.valueFormatter;\n      }\n      // Handle useValueFormatterForExport (boolean flag)\n      if (templateProps.useValueFormatterForExport !== undefined) {\n        mergedProperties.useValueFormatterForExport = templateProps.useValueFormatterForExport;\n      }\n      \n      // Handle headerStyle - convert back to function if needed\n      if (templateProps.headerStyle) {\n        const headerStyle = templateProps.headerStyle;\n        if (headerStyle._isHeaderStyleConfig) {\n          // Convert to function format\n          mergedProperties.headerStyle = (params: { floatingFilter?: boolean }) => {\n            if (params?.floatingFilter) {\n              return headerStyle.floating || null;\n            }\n            return headerStyle.regular || null;\n          };\n        } else if (typeof headerStyle === 'object') {\n          // Legacy format - just a style object\n          mergedProperties.headerStyle = (params: { floatingFilter?: boolean }) => {\n            if (!params?.floatingFilter) {\n              return headerStyle;\n            }\n            return null;\n          };\n        }\n      }\n      \n      // Handle cellStyle - recreate function if needed\n      if (templateProps.cellStyle) {\n        const cellStyle = templateProps.cellStyle;\n        if (cellStyle.type === 'function' && cellStyle.formatString) {\n          // We'll handle this after merging, store the config for now\n          mergedProperties._cellStyleConfig = cellStyle;\n        } else if (typeof cellStyle === 'object' && !cellStyle.type) {\n          // Static style object\n          mergedProperties.cellStyle = cellStyle;\n        }\n      }\n      \n      // Merge all other properties (later templates override earlier ones)\n      Object.keys(templateProps).forEach(key => {\n        if (key !== 'valueFormatter' && key !== 'headerStyle' && key !== 'useValueFormatterForExport' && key !== 'cellStyle') {\n          mergedProperties[key] = templateProps[key];\n        }\n      });\n    });\n    \n    console.log('[BulkActionsPanel] Merged template properties:', {\n      appliedTemplates: appliedTemplateNames,\n      mergedPropertiesCount: Object.keys(mergedProperties).length,\n      properties: Object.keys(mergedProperties),\n      hasHeaderStyle: !!mergedProperties.headerStyle,\n      headerStyleType: mergedProperties.headerStyle ? typeof mergedProperties.headerStyle : 'none',\n      hasValueFormatter: !!mergedProperties.valueFormatter\n    });\n    \n    // Handle cellStyle config if present\n    if (mergedProperties._cellStyleConfig) {\n      const cellStyleConfig = mergedProperties._cellStyleConfig;\n      delete mergedProperties._cellStyleConfig; // Remove temporary config\n      \n      // Import and recreate the cellStyle function\n      import('../../../utils/formatters').then(({ createCellStyleFunction }) => {\n        const styleFunc = createCellStyleFunction(cellStyleConfig.formatString, cellStyleConfig.baseStyle);\n        // Attach metadata for future serialization\n        Object.defineProperty(styleFunc, '__formatString', { \n          value: cellStyleConfig.formatString, \n          writable: false,\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(styleFunc, '__baseStyle', { \n          value: cellStyleConfig.baseStyle, \n          writable: false,\n          enumerable: false,\n          configurable: true\n        });\n        // Update cellStyle separately\n        updateBulkProperties({ cellStyle: styleFunc });\n      });\n    }\n    \n    // Apply all merged properties at once\n    updateBulkProperties(mergedProperties);\n    \n    // Track which templates were applied to each selected column\n    selectedColumns.forEach(columnId => {\n      // For multiple templates, we'll track the combined template names\n      const combinedTemplateName = appliedTemplateNames.join(' + ');\n      const combinedTemplateId = selectedTemplateIds.join('+');\n      setAppliedTemplate(columnId, combinedTemplateId, combinedTemplateName);\n    });\n    \n    setSelectedTemplateIds([]); // Clear selection after applying\n  }, [selectedTemplateIds, templates, updateBulkProperties, selectedColumns, setAppliedTemplate]);\n\n  // Delete template\n  const deleteTemplate = useCallback(() => {\n    if (!templateToDelete) return;\n    \n    // Prevent deleting system templates\n    const templateToDeleteObj = templates.find(t => t.id === templateToDelete);\n    if (templateToDeleteObj?.isSystem) {\n      console.warn('Cannot delete system template');\n      setShowDeleteDialog(false);\n      setTemplateToDelete('');\n      return;\n    }\n    \n    const newTemplates = userTemplates.filter(t => t.id !== templateToDelete);\n    saveTemplates(newTemplates);\n    setShowDeleteDialog(false);\n    setTemplateToDelete('');\n    \n    // Clear selection if deleted template was selected\n    if (selectedTemplateIds.includes(templateToDelete)) {\n      setSelectedTemplateIds(selectedTemplateIds.filter(id => id !== templateToDelete));\n    }\n  }, [templateToDelete, userTemplates, saveTemplates, selectedTemplateIds, templates]);\n\n  // Clear all customizations from selected columns\n  const clearSelectedCustomizations = useCallback(() => {\n    // Use the same comprehensive list as templates\n    const propertiesToClear = TEMPLATE_PROPERTIES.filter(prop => !prop.startsWith('_'));\n    \n    // Build object with all properties set to undefined\n    const clearProperties: Record<string, undefined> = {};\n    propertiesToClear.forEach(property => {\n      clearProperties[property] = undefined;\n    });\n    \n    // Batch clear all properties at once\n    updateBulkProperties(clearProperties);\n  }, [updateBulkProperties]);\n\n  // Count pending changes\n  const changeCount = useMemo(() => {\n    let count = 0;\n    pendingChanges.forEach((changes) => {\n      count += Object.keys(changes).length;\n    });\n    return count;\n  }, [pendingChanges]);\n\n  const isDisabled = selectedColumns.size === 0;\n  const canSaveTemplate = selectedColumns.size === 1;\n  const hasTemplates = userTemplates.length > 0;\n\n  return (\n    <div className=\"h-full flex flex-col\">\n      {/* Compact header section */}\n      <div className=\"px-4 py-2 border-b bg-card/50\">\n        <h3 className=\"text-xs font-semibold uppercase text-muted-foreground tracking-wider\">\n          Templates\n        </h3>\n        {selectedColumns.size > 1 && (\n          <Alert className=\"mt-1\">\n            <AlertCircle className=\"h-4 w-4\" />\n            <AlertDescription className=\"text-xs\">\n              Select only one column to save as a template\n            </AlertDescription>\n          </Alert>\n        )}\n      </div>\n\n      {/* Scrollable content area - expanded */}\n      <div className=\"flex-1 overflow-y-auto min-h-0\">\n        <div className=\"p-3\">\n          {/* Template Selection */}\n          {!hasTemplates ? (\n            <div className=\"px-3 py-4 text-center text-xs text-muted-foreground border rounded-md bg-muted/20\">\n              <p className=\"mb-1\">No templates saved</p>\n              <p className=\"text-xs opacity-70\">Save current settings as a template</p>\n            </div>\n          ) : (\n            <div className=\"space-y-2\">\n              <div className=\"flex items-center justify-between\">\n                <div className=\"text-xs text-muted-foreground\">\n                  {selectedTemplateIds.length} selected\n                </div>\n                <div className=\"flex gap-1\">\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    className=\"h-6 px-2 text-xs\"\n                    onClick={() => setSelectedTemplateIds(templates.map(t => t.id))}\n                    disabled={selectedTemplateIds.length === templates.length}\n                  >\n                    All\n                  </Button>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    className=\"h-6 px-2 text-xs\"\n                    onClick={() => setSelectedTemplateIds([])}\n                    disabled={selectedTemplateIds.length === 0}\n                  >\n                    None\n                  </Button>\n                </div>\n              </div>\n              \n              {/* Template list - expanded height */}\n              <div className=\"max-h-80 overflow-y-auto border rounded-lg bg-background\">\n                <div className=\"p-2 space-y-1\">\n                  {templates.map((template) => (\n                    <div \n                      key={template.id} \n                      className={`group flex items-center gap-3 p-2 rounded-md border transition-all hover:bg-muted/50 ${\n                        selectedTemplateIds.includes(template.id) \n                          ? 'bg-muted/30 border-primary/20' \n                          : 'border-transparent hover:border-border'\n                      } ${\n                        template.isSystem \n                          ? 'bg-gradient-to-r from-blue-50/50 to-transparent dark:from-blue-950/20 dark:to-transparent' \n                          : ''\n                      }`}\n                    >\n                      <Checkbox\n                        id={`template-${template.id}`}\n                        checked={selectedTemplateIds.includes(template.id)}\n                        onCheckedChange={(checked) => {\n                          if (checked) {\n                            setSelectedTemplateIds([...selectedTemplateIds, template.id]);\n                          } else {\n                            setSelectedTemplateIds(selectedTemplateIds.filter(id => id !== template.id));\n                          }\n                        }}\n                        className=\"shrink-0\"\n                      />\n                      \n                      <div className=\"flex-1 min-w-0\">\n                        <div className=\"flex items-center gap-2\">\n                          <label \n                            htmlFor={`template-${template.id}`} \n                            className=\"text-sm font-medium cursor-pointer truncate\"\n                          >\n                            {template.name}\n                          </label>\n                          {template.isSystem && (\n                            <Sparkles className=\"h-3 w-3 text-blue-500 shrink-0\" title=\"System template\" />\n                          )}\n                        </div>\n                        {template.isSystem && (\n                          <p className=\"text-xs text-muted-foreground mt-0.5 truncate\">\n                            {getSystemTemplateDescription(template.id)}\n                          </p>\n                        )}\n                      </div>\n                      \n                      {!template.isSystem && (\n                        <div className=\"flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity\">\n                          <Button\n                            variant=\"ghost\"\n                            size=\"sm\"\n                            className=\"h-6 w-6 p-0\"\n                            onClick={(e) => {\n                              e.stopPropagation();\n                              setEditingTemplateId(template.id);\n                              setTemplateName(template.name);\n                              setShowSaveDialog(true);\n                            }}\n                            title=\"Edit template\"\n                          >\n                            <Edit2 className=\"h-3 w-3\" />\n                          </Button>\n                          <Button\n                            variant=\"ghost\"\n                            size=\"sm\"\n                            className=\"h-6 w-6 p-0 text-destructive hover:text-destructive\"\n                            onClick={(e) => {\n                              e.stopPropagation();\n                              setTemplateToDelete(template.id);\n                              setShowDeleteDialog(true);\n                            }}\n                            title=\"Delete template\"\n                          >\n                            <Trash2 className=\"h-3 w-3\" />\n                          </Button>\n                        </div>\n                      )}\n                    </div>\n                  ))}\n                </div>\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Compact footer section with horizontal layouts */}\n      <div className=\"border-t bg-card/50 p-3 space-y-3\">\n        {/* Apply Templates Button - full width */}\n        <Button\n          variant=\"default\"\n          size=\"sm\"\n          className=\"w-full h-8 text-sm gap-2\"\n          onClick={applyTemplate}\n          disabled={!selectedTemplateIds.length}\n          title={selectedTemplateIds.length ? `Apply ${selectedTemplateIds.length} template${selectedTemplateIds.length !== 1 ? 's' : ''}` : \"Select templates to apply\"}\n        >\n          <Copy className=\"h-4 w-4\" />\n          Apply Templates {selectedTemplateIds.length > 0 && `(${selectedTemplateIds.length})`}\n        </Button>\n\n        {/* Action buttons - horizontal layout */}\n        <div className=\"flex gap-2\">\n          <Button\n            variant=\"outline\"\n            size=\"sm\"\n            className=\"flex-1 h-8 text-sm gap-1\"\n            onClick={() => {\n              setEditingTemplateId('');\n              setTemplateName('');\n              setShowSaveDialog(true);\n            }}\n            disabled={!canSaveTemplate}\n            title={!canSaveTemplate ? \"Select only one column to save as template\" : \"Save current column as template\"}\n          >\n            <Save className=\"h-3 w-3\" />\n            Save New\n          </Button>\n          <Button\n            variant=\"destructive\"\n            size=\"sm\"\n            className=\"flex-1 h-8 text-sm gap-1\"\n            onClick={clearSelectedCustomizations}\n            disabled={isDisabled}\n          >\n            <Eraser className=\"h-3 w-3\" />\n            Clear Selected\n          </Button>\n        </div>\n\n        {/* Compact status grid */}\n        <div className=\"grid grid-cols-2 gap-1 text-xs\">\n          <div className=\"flex items-center justify-between p-1.5 rounded bg-muted/30\">\n            <span className=\"text-muted-foreground\">Selected</span>\n            <span className=\"font-medium\">{selectedColumns.size}</span>\n          </div>\n          <div className=\"flex items-center justify-between p-1.5 rounded bg-muted/30\">\n            <span className=\"text-muted-foreground\">Changes</span>\n            <span className=\"font-medium\">{changeCount}</span>\n          </div>\n        </div>\n      </div>\n\n      {/* Save Template Dialog */}\n      <Dialog open={showSaveDialog} onOpenChange={setShowSaveDialog}>\n        <DialogContent className=\"sm:max-w-[425px]\">\n          <DialogHeader>\n            <DialogTitle>\n              {editingTemplateId ? 'Update Template' : 'Save as Template'}\n            </DialogTitle>\n            <DialogDescription>\n              Save the current column configuration as a reusable template\n            </DialogDescription>\n          </DialogHeader>\n          <div className=\"grid gap-4 py-4\">\n            <div className=\"space-y-2\">\n              <label htmlFor=\"template-name\" className=\"text-sm font-medium\">\n                Template Name\n              </label>\n              <Input\n                id=\"template-name\"\n                value={templateName}\n                onChange={(e) => setTemplateName(e.target.value)}\n                placeholder=\"e.g., Currency Column\"\n                className=\"h-9\"\n              />\n            </div>\n          </div>\n          <DialogFooter>\n            <Button\n              variant=\"outline\"\n              onClick={() => {\n                setShowSaveDialog(false);\n                setTemplateName('');\n                setEditingTemplateId('');\n              }}\n            >\n              Cancel\n            </Button>\n            <Button\n              onClick={saveAsTemplate}\n              disabled={!templateName.trim()}\n            >\n              {editingTemplateId ? 'Update' : 'Save'}\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n\n      {/* Delete Template Dialog */}\n      <Dialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>\n        <DialogContent className=\"sm:max-w-[425px]\">\n          <DialogHeader>\n            <DialogTitle>Delete Template</DialogTitle>\n            <DialogDescription>\n              Are you sure you want to delete this template? This action cannot be undone.\n            </DialogDescription>\n          </DialogHeader>\n          <DialogFooter>\n            <Button\n              variant=\"outline\"\n              onClick={() => {\n                setShowDeleteDialog(false);\n                setTemplateToDelete('');\n              }}\n            >\n              Cancel\n            </Button>\n            <Button\n              variant=\"destructive\"\n              onClick={deleteTemplate}\n            >\n              Delete\n            </Button>\n          </DialogFooter>\n        </DialogContent>\n      </Dialog>\n    </div>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/panels/ColumnSelectorPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":378,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":378,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14995,14998],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14995,14998],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useMemo, useCallback, useState } from 'react';\nimport { Input } from '@/components/ui/input';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { Badge } from '@/components/ui/badge';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';\nimport { Search, Columns3, Filter, Eye, EyeOff, Hash, Type, Calendar, ToggleLeft, Package, CircleDot, DollarSign, Palette, Edit3, Settings, X } from 'lucide-react';\nimport { ColDef } from 'ag-grid-community';\nimport { useColumnCustomizationStore } from '../store/columnCustomization.store';\nimport { useVirtualizer } from '@tanstack/react-virtual';\nimport { CustomizationBadges, CustomizationType } from '../components/CustomizationBadges';\nimport { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';\nimport { cn } from '@/lib/utils';\n\n// Helper function to get icon component based on column type\nconst getColumnIcon = (type: string) => {\n  switch (type) {\n    case 'number':\n    case 'numericColumn':\n      return Hash;\n    case 'currency':\n      return DollarSign;\n    case 'date':\n    case 'dateColumn':\n      return Calendar;\n    case 'text':\n    case 'textColumn':\n      return Type;\n    case 'boolean':\n    case 'booleanColumn':\n      return ToggleLeft;\n    case 'object':\n      return Package;\n    default:\n      return CircleDot;\n  }\n};\n\nexport const ColumnSelectorPanel: React.FC = React.memo(() => {\n  const {\n    selectedColumns,\n    columnDefinitions,\n    columnState,\n    searchTerm,\n    cellDataTypeFilter,\n    visibilityFilter,\n    templateColumns,\n    appliedTemplates,\n    toggleColumnSelection,\n    selectColumns,\n    deselectColumns,\n    setSearchTerm,\n    setCellDataTypeFilter,\n    setVisibilityFilter,\n    toggleTemplateColumn\n  } = useColumnCustomizationStore();\n\n  const parentRef = React.useRef<HTMLDivElement>(null);\n\n  // Get all columns as array\n  const allColumns = useMemo(() => {\n    return Array.from(columnDefinitions.values());\n  }, [columnDefinitions]);\n\n  // Get available cellDataType options\n  const availableCellDataTypes = useMemo(() => {\n    const types = new Set<string>();\n    allColumns.forEach(col => {\n      if (col.cellDataType) {\n        types.add(col.cellDataType);\n      }\n    });\n    return Array.from(types).sort();\n  }, [allColumns]);\n\n  // Filter columns based on search, cellDataType, and visibility\n  const filteredColumns = useMemo(() => {\n    let filtered = allColumns;\n\n    // Filter by search term\n    if (searchTerm) {\n      const term = searchTerm.toLowerCase();\n      filtered = filtered.filter(col =>\n        col.field?.toLowerCase().includes(term) ||\n        col.headerName?.toLowerCase().includes(term)\n      );\n    }\n\n    // Filter by cellDataType\n    if (cellDataTypeFilter && cellDataTypeFilter !== 'all') {\n      filtered = filtered.filter(col => col.cellDataType === cellDataTypeFilter);\n    }\n\n    // Filter by visibility using column state\n    if (visibilityFilter !== 'all') {\n      filtered = filtered.filter(col => {\n        // Try multiple ways to match column with state\n        const field = col.field || '';\n        const colId = col.colId || field;\n        \n        // Try to find column state by field first, then by colId\n        let colState = columnState.get(field);\n        if (!colState && field !== colId) {\n          colState = columnState.get(colId);\n        }\n        \n        // Check if column state exists at all - if not, the grid API might not be returning state for all columns\n        // AG-Grid only includes columns in getColumnState if they have been modified from defaults\n        // So if a column has no state, it means it's using default settings (visible)\n        const isHidden = colState?.hide === true; // Only hidden if explicitly set to true\n        \n        return visibilityFilter === 'hidden' ? isHidden : !isHidden;\n      });\n    }\n\n    return filtered;\n  }, [allColumns, searchTerm, cellDataTypeFilter, visibilityFilter, columnState]);\n\n  // Prepare items for virtual scrolling (simple flat list)\n  const flatItems = useMemo(() => {\n    return filteredColumns.map(column => ({ \n      type: 'column' as const, \n      column,\n      id: column.field || column.colId || ''\n    }));\n  }, [filteredColumns]);\n\n  // Virtual scrolling setup\n  const virtualizer = useVirtualizer({\n    count: flatItems.length,\n    getScrollElement: () => parentRef.current,\n    estimateSize: () => 40, // Estimated height per item\n    overscan: 5\n  });\n\n  const selectAllFilteredColumns = useCallback(() => {\n    const columnIds = filteredColumns\n      .map(col => col.field || col.colId || '')\n      .filter(id => id && !selectedColumns.has(id));\n    if (columnIds.length > 0) {\n      selectColumns(columnIds);\n    }\n  }, [filteredColumns, selectedColumns, selectColumns]);\n\n  const deselectAllFilteredColumns = useCallback(() => {\n    const columnIds = filteredColumns\n      .map(col => col.field || col.colId || '')\n      .filter(id => id && selectedColumns.has(id));\n    if (columnIds.length > 0) {\n      deselectColumns(columnIds);\n    }\n  }, [filteredColumns, selectedColumns, deselectColumns]);\n\n  const isAllSelected = useMemo(() => \n    filteredColumns.length > 0 &&\n    filteredColumns.every(col => selectedColumns.has(col.field || col.colId || '')),\n    [filteredColumns, selectedColumns]\n  );\n  const isIndeterminate = useMemo(() => \n    filteredColumns.some(col => selectedColumns.has(col.field || col.colId || '')) &&\n    !isAllSelected,\n    [filteredColumns, selectedColumns, isAllSelected]\n  );\n\n  // Count of filtered columns that are selected\n  const filteredSelectedCount = useMemo(() => \n    filteredColumns.filter(col =>\n      selectedColumns.has(col.field || col.colId || '')\n    ).length,\n    [filteredColumns, selectedColumns]\n  );\n\n  return (\n    <TooltipProvider>\n      <div className=\"h-full flex flex-col\">\n        {/* Modern Header */}\n        <div className=\"px-4 py-3 border-b border-border/40 bg-gradient-to-r from-muted/15 to-muted/5 backdrop-blur-sm\">\n          <div className=\"flex items-center gap-3\">\n            <div className=\"p-1.5 rounded-md bg-gradient-to-br from-primary/20 to-primary/10 border border-primary/20\">\n              <Columns3 className=\"h-4 w-4 text-primary\" />\n            </div>\n            <span className=\"text-sm font-semibold tracking-tight\">Columns</span>\n            <Badge variant=\"outline\" className=\"text-xs px-2 py-1 ml-auto font-medium rounded-md border-border/60\">\n              {filteredColumns.length}\n            </Badge>\n          </div>\n        </div>\n\n        <div className=\"flex-1 flex flex-col p-4\">\n          {/* Modern Search Bar */}\n          <div className=\"relative mb-3\">\n            <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground h-4 w-4\" />\n            <Input\n              placeholder=\"Search columns...\"\n              value={searchTerm}\n              onChange={(e) => setSearchTerm(e.target.value)}\n              className=\"pl-9 h-9 text-sm rounded-lg border-border/60 bg-background/80 backdrop-blur-sm focus:border-primary/60 focus:ring-primary/20 transition-all duration-200\"\n            />\n          </div>\n\n          {/* Filters */}\n          <div className=\"space-y-3 mb-4\">\n            {/* CellDataType Filter */}\n            <Select\n              value={cellDataTypeFilter}\n              onValueChange={setCellDataTypeFilter}\n            >\n              <SelectTrigger className=\"h-9 text-sm rounded-lg border-border/60 bg-background/80 backdrop-blur-sm\">\n                <Filter className=\"h-4 w-4 mr-2\" />\n                <SelectValue placeholder=\"Filter by data type\" />\n              </SelectTrigger>\n              <SelectContent className=\"rounded-lg border-border/60 bg-background/95 backdrop-blur-md\">\n                <SelectItem value=\"all\" className=\"text-sm\">All Data Types</SelectItem>\n                {availableCellDataTypes.map(type => {\n                  const TypeIcon = getColumnIcon(type);\n                  return (\n                    <SelectItem key={type} value={type} className=\"text-sm\">\n                      <div className=\"flex items-center gap-2\">\n                        <TypeIcon className=\"h-4 w-4 text-muted-foreground\" />\n                        <span className=\"capitalize\">{type}</span>\n                      </div>\n                    </SelectItem>\n                  );\n                })}\n              </SelectContent>\n            </Select>\n\n            {/* Visibility Filter */}\n            <Select\n              value={visibilityFilter}\n              onValueChange={(value: 'all' | 'visible' | 'hidden') => setVisibilityFilter(value)}\n            >\n              <SelectTrigger className=\"h-9 text-sm rounded-lg border-border/60 bg-background/80 backdrop-blur-sm\">\n                {visibilityFilter === 'visible' ? (\n                  <Eye className=\"h-4 w-4 mr-2\" />\n                ) : visibilityFilter === 'hidden' ? (\n                  <EyeOff className=\"h-4 w-4 mr-2\" />\n                ) : (\n                  <Eye className=\"h-4 w-4 mr-2\" />\n                )}\n                <SelectValue placeholder=\"Filter by visibility\" />\n              </SelectTrigger>\n              <SelectContent className=\"rounded-lg border-border/60 bg-background/95 backdrop-blur-md\">\n                <SelectItem value=\"all\" className=\"text-sm\">\n                  <div className=\"flex items-center gap-2\">\n                    <Eye className=\"h-4 w-4\" />\n                    <span>All Columns</span>\n                  </div>\n                </SelectItem>\n                <SelectItem value=\"visible\" className=\"text-sm\">\n                  <div className=\"flex items-center gap-2\">\n                    <Eye className=\"h-4 w-4 text-green-600\" />\n                    <span>Visible Columns</span>\n                  </div>\n                </SelectItem>\n                <SelectItem value=\"hidden\" className=\"text-sm\">\n                  <div className=\"flex items-center gap-2\">\n                    <EyeOff className=\"h-4 w-4 text-red-600\" />\n                    <span>Hidden Columns</span>\n                  </div>\n                </SelectItem>\n              </SelectContent>\n            </Select>\n          </div>\n\n          {/* Modern Selection Controls */}\n          <div className=\"flex items-center gap-2.5 mb-4\">\n            <Checkbox\n              checked={isAllSelected ? true : isIndeterminate ? \"indeterminate\" : false}\n              onCheckedChange={(checked) => {\n                if (checked === true || checked === \"indeterminate\") {\n                  selectAllFilteredColumns();\n                } else {\n                  deselectAllFilteredColumns();\n                }\n              }}\n              className=\"rounded\"\n            />\n            <span className=\"text-xs font-medium text-foreground\">\n              {(searchTerm || cellDataTypeFilter !== 'all' || visibilityFilter !== 'all') ? 'All Filtered' : 'All'}\n            </span>\n            {filteredSelectedCount > 0 && (\n              <Badge variant=\"secondary\" className=\"text-xs px-2 py-0.5 font-medium rounded-md bg-secondary/80 border border-secondary/40\">\n                {filteredSelectedCount}/{filteredColumns.length}\n              </Badge>\n            )}\n          </div>\n\n          {/* Virtual Column List */}\n          <div className=\"flex-1 -mx-1\">\n            <div\n              ref={parentRef}\n              className=\"h-full overflow-auto px-1 scrollbar-thin\"\n              style={{ contain: 'strict' }}\n            >\n              <div\n                style={{\n                  height: `${virtualizer.getTotalSize()}px`,\n                  width: '100%',\n                  position: 'relative',\n                }}\n              >\n                {virtualizer.getVirtualItems().map((virtualItem) => {\n                  const item = flatItems[virtualItem.index];\n\n                  return (\n                    <div\n                      key={virtualItem.key}\n                      style={{\n                        position: 'absolute',\n                        top: 0,\n                        left: 0,\n                        width: '100%',\n                        height: `${virtualItem.size}px`,\n                        transform: `translateY(${virtualItem.start}px)`,\n                      }}\n                    >\n                      <ColumnItem\n                        column={item.column}\n                        columnId={item.id}\n                        selected={selectedColumns.has(item.id)}\n                        isTemplate={templateColumns instanceof Set ? templateColumns.has(item.id) : false}\n                        isHidden={(() => {\n                          // Try to find column state by field first, then by colId\n                          const field = item.column.field || '';\n                          const colId = item.column.colId || field;\n                          let colState = columnState.get(field);\n                          if (!colState && field !== colId) {\n                            colState = columnState.get(colId);\n                          }\n                          return colState?.hide || false;\n                        })()}\n                        appliedTemplate={appliedTemplates.get(item.id)}\n                        onToggle={toggleColumnSelection}\n                        onToggleTemplate={toggleTemplateColumn}\n                      />\n                    </div>\n                  );\n                })}\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </TooltipProvider>\n  );\n});\n\nColumnSelectorPanel.displayName = 'ColumnSelectorPanel';\n\n// Clean Column Item Component\nconst ColumnItem: React.FC<{\n  column: ColDef;\n  columnId: string;\n  selected: boolean;\n  isTemplate: boolean;\n  isHidden: boolean;\n  appliedTemplate?: { templateId: string; templateName: string; appliedAt: number };\n  onToggle: (columnId: string) => void;\n  onToggleTemplate: (columnId: string) => void;\n}> = React.memo(({ column, columnId, selected, isTemplate: _isTemplate, isHidden, appliedTemplate, onToggle, onToggleTemplate: _onToggleTemplate }) => {\n  const { removeColumnCustomization, removeAppliedTemplate, pendingChanges } = useColumnCustomizationStore();\n  const [isHoveringTemplate, setIsHoveringTemplate] = useState(false);\n  const iconKey = (column.cellDataType || column.type || 'text') as string;\n  const IconComponent = getColumnIcon(iconKey);\n\n  // Detect customizations including template info\n  const customizations = useMemo(() => {\n    const customs: CustomizationType[] = [];\n    \n    // Get pending changes for this column\n    const pending = pendingChanges.get(columnId) || {};\n    \n    // Merge original column with pending changes to get effective column state\n    const effectiveColumn = { ...column, ...pending };\n    \n    // Helper function to check if a value exists and is not undefined\n    const hasValue = (value: any) => value !== undefined && value !== null;\n    \n    // Check for styling customizations\n    const hasStyle = hasValue(effectiveColumn.cellStyle) || hasValue(effectiveColumn.headerStyle) || \n                     hasValue(effectiveColumn.cellClass) || hasValue(effectiveColumn.headerClass);\n    if (hasStyle) {\n      let styleCount = 0;\n      if (hasValue(effectiveColumn.cellStyle)) styleCount++;\n      if (hasValue(effectiveColumn.headerStyle)) styleCount++;\n      if (hasValue(effectiveColumn.cellClass)) styleCount++;\n      if (hasValue(effectiveColumn.headerClass)) styleCount++;\n      customs.push({ \n        type: 'style', \n        label: 'Styling customizations', \n        icon: Palette,\n        count: styleCount\n      });\n    }\n\n    // Check for formatter\n    if (hasValue(effectiveColumn.valueFormatter)) {\n      customs.push({ \n        type: 'formatter', \n        label: 'Value formatter', \n        icon: Hash \n      });\n    }\n\n    // Check for filter\n    if (hasValue(effectiveColumn.filter) || hasValue(effectiveColumn.filterParams)) {\n      customs.push({ \n        type: 'filter', \n        label: 'Filter settings', \n        icon: Filter \n      });\n    }\n\n    // Check for editor\n    if (hasValue(effectiveColumn.cellEditor) || hasValue(effectiveColumn.cellEditorParams)) {\n      customs.push({ \n        type: 'editor', \n        label: 'Cell editor', \n        icon: Edit3 \n      });\n    }\n\n    // Check for general settings (width, pinning, etc)\n    const hasGeneral = hasValue(effectiveColumn.width) || hasValue(effectiveColumn.minWidth) || hasValue(effectiveColumn.maxWidth) || \n                      hasValue(effectiveColumn.pinned) || hasValue(effectiveColumn.lockPosition) || hasValue(effectiveColumn.lockVisible);\n    if (hasGeneral) {\n      let generalCount = 0;\n      if (hasValue(effectiveColumn.width) || hasValue(effectiveColumn.minWidth) || hasValue(effectiveColumn.maxWidth)) generalCount++;\n      if (hasValue(effectiveColumn.pinned)) generalCount++;\n      if (hasValue(effectiveColumn.lockPosition) || hasValue(effectiveColumn.lockVisible)) generalCount++;\n      customs.push({ \n        type: 'general', \n        label: 'General settings', \n        icon: Settings,\n        count: generalCount\n      });\n    }\n\n    return customs;\n  }, [column, columnId, pendingChanges]);\n\n  const handleToggle = useCallback(() => {\n    onToggle(columnId);\n  }, [columnId, onToggle]);\n\n  const _handleToggleTemplate = useCallback((e: React.MouseEvent) => {\n    e.stopPropagation();\n    _onToggleTemplate(columnId);\n  }, [columnId, _onToggleTemplate]);\n\n  const handleRemoveCustomization = useCallback((type: string) => {\n    removeColumnCustomization(columnId, type);\n  }, [columnId, removeColumnCustomization]);\n\n  return (\n    <div \n      className={`relative flex items-center gap-2 px-3 py-1.5 rounded-md hover:bg-muted/50 transition-colors group cursor-pointer ${\n        selected ? 'bg-muted/30' : ''\n      }`}\n      onClick={handleToggle}\n    >\n      {selected && (\n        <div className=\"absolute left-0 h-full w-1 bg-primary rounded-r\" />\n      )}\n      <Checkbox\n        checked={selected}\n        onCheckedChange={handleToggle}\n        onClick={(e) => e.stopPropagation()}\n        className=\"shrink-0\"\n      />\n      <IconComponent className=\"h-4 w-4 shrink-0 text-muted-foreground\" />\n      <span className=\"text-sm flex-1 flex items-center gap-1 min-w-0\">\n        <Tooltip>\n          <TooltipTrigger asChild>\n            <span className={`truncate ${isHidden ? 'opacity-50' : ''}`}>\n              {column.headerName || column.field}\n            </span>\n          </TooltipTrigger>\n          <TooltipContent>\n            {column.headerName || column.field}\n          </TooltipContent>\n        </Tooltip>\n        {isHidden && (\n          <EyeOff className=\"h-3 w-3 text-muted-foreground shrink-0\" />\n        )}\n      </span>\n      \n      {/* Customization Count with Popover - moved to the right */}\n      {(customizations.length > 0 || appliedTemplate) && (\n        <Popover>\n          <PopoverTrigger asChild>\n            <div \n              className=\"h-5 w-5 shrink-0 rounded-full bg-primary/10 flex items-center justify-center cursor-pointer hover:bg-primary/20 transition-colors ml-auto\"\n              title={`${customizations.length + (appliedTemplate ? 1 : 0)} customization${customizations.length + (appliedTemplate ? 1 : 0) !== 1 ? 's' : ''} applied`}\n            >\n              <span className=\"text-[10px] font-medium text-primary\">{customizations.length + (appliedTemplate ? 1 : 0)}</span>\n            </div>\n          </PopoverTrigger>\n          <PopoverContent side=\"left\" align=\"center\" className=\"w-auto p-3\">\n            <div className=\"space-y-2\">\n              {appliedTemplate && (\n                <div className=\"mb-2\">\n                  <p className=\"text-xs font-medium text-muted-foreground mb-1\">Template:</p>\n                  <div \n                    className=\"relative inline-block\"\n                    onMouseEnter={() => setIsHoveringTemplate(true)}\n                    onMouseLeave={() => setIsHoveringTemplate(false)}\n                  >\n                    <Badge \n                      variant=\"outline\" \n                      className={cn(\n                        \"text-xs px-2 py-0.5 transition-all\",\n                        isHoveringTemplate && \"pr-7\"\n                      )}\n                    >\n                      {appliedTemplate.templateName}\n                    </Badge>\n                    {isHoveringTemplate && (\n                      <button\n                        onClick={(e) => {\n                          e.stopPropagation();\n                          console.log('[ColumnSelector] Removing template:', appliedTemplate.templateName, 'from column:', columnId);\n                          removeAppliedTemplate(columnId);\n                          setIsHoveringTemplate(false);\n                        }}\n                        className=\"absolute right-1 top-1/2 -translate-y-1/2 h-4 w-4 flex items-center justify-center rounded-sm hover:bg-black/10 dark:hover:bg-white/10 transition-colors\"\n                        aria-label=\"Remove template\"\n                      >\n                        <X className=\"h-3 w-3\" />\n                      </button>\n                    )}\n                  </div>\n                </div>\n              )}\n              {customizations.length > 0 && (\n                <>\n                  <p className=\"text-xs font-medium mb-2\">Customizations:</p>\n                  <CustomizationBadges\n                    customizations={customizations}\n                    onRemove={handleRemoveCustomization}\n                    className=\"flex-wrap\"\n                    maxVisible={10} // Show all in popover\n                  />\n                </>\n              )}\n            </div>\n          </PopoverContent>\n        </Popover>\n      )}\n    </div>\n  );\n}, (prevProps, nextProps) => {\n  // Custom comparison to prevent unnecessary re-renders\n  return (\n    prevProps.selected === nextProps.selected &&\n    prevProps.isTemplate === nextProps.isTemplate &&\n    prevProps.isHidden === nextProps.isHidden &&\n    prevProps.columnId === nextProps.columnId &&\n    prevProps.column === nextProps.column && // Compare entire column object for customization changes\n    prevProps.appliedTemplate?.templateId === nextProps.appliedTemplate?.templateId // Check template changes\n  );\n});\n\nColumnItem.displayName = 'ColumnItem';","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/panels/PropertyEditorPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/store/columnCustomization.store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/tabs/AdvancedTab.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/tabs/EditorsTab.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/tabs/FiltersTab.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/tabs/FormatTab.tsx","messages":[{"ruleId":"unused-imports/no-unused-imports","severity":2,"message":"'Select' is defined but never used.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":16,"fix":{"range":[280,288],"text":""}},{"ruleId":"unused-imports/no-unused-imports","severity":2,"message":"'SelectContent' is defined but never used.","line":6,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":31,"fix":{"range":[288,303],"text":""}},{"ruleId":"unused-imports/no-unused-imports","severity":2,"message":"'SelectItem' is defined but never used.","line":6,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":43,"fix":{"range":[303,315],"text":""}},{"ruleId":"unused-imports/no-unused-imports","severity":2,"message":"'SelectTrigger' is defined but never used.","line":6,"column":45,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":58,"fix":{"range":[315,330],"text":""}},{"ruleId":"unused-imports/no-unused-imports","severity":2,"message":"'SelectValue' is defined but never used.","line":6,"column":60,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":71,"fix":{"range":[329,342],"text":""}},{"ruleId":"unused-imports/no-unused-imports","severity":2,"message":"'Badge' is defined but never used.","line":9,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":15,"fix":{"range":[539,586],"text":""}},{"ruleId":"unused-imports/no-unused-imports","severity":2,"message":"'Tooltip' is defined but never used.","line":13,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":10,"fix":{"range":[722,733],"text":""}},{"ruleId":"unused-imports/no-unused-imports","severity":2,"message":"'TooltipContent' is defined but never used.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":17,"fix":{"range":[733,751],"text":""}},{"ruleId":"unused-imports/no-unused-imports","severity":2,"message":"'TooltipProvider' is defined but never used.","line":15,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":18,"fix":{"range":[751,770],"text":""}},{"ruleId":"unused-imports/no-unused-imports","severity":2,"message":"'TooltipTrigger' is defined but never used.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":17,"fix":{"range":[769,787],"text":""}},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'uiMode' is assigned a value but never used. Allowed unused args must match /^_/u.","line":94,"column":29,"nodeType":null,"messageId":"unusedVar","endLine":94,"endColumn":35},{"ruleId":"unused-imports/no-unused-vars","severity":1,"message":"'updateBulkProperty' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":101,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":101,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":122,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4635,4638],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4635,4638],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":143,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5634,5637],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5634,5637],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":157,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":157,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6337,6340],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6337,6340],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":177,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":177,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7237,7240],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7237,7240],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":192,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7822,7825],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7822,7825],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":278,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":278,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11543,11546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11543,11546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":536,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":536,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21722,21725],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21722,21725],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":541,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":541,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21890,21893],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21890,21893],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":548,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":548,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22176,22179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22176,22179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":549,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":549,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22236,22239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22236,22239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":563,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":563,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23033,23036],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23033,23036],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":612,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":612,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25327,25330],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25327,25330],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":613,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":613,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25389,25392],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25389,25392],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":23,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":10,"fixableWarningCount":0,"source":"import React, { useState, useCallback, useMemo } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { Label } from '@/components/ui/label';\nimport { Separator } from '@/components/ui/separator';\nimport { ScrollArea } from '@/components/ui/scroll-area';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Alert, AlertDescription } from '@/components/ui/alert';\nimport { Badge } from '@/components/ui/badge';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Input } from '@/components/ui/input';\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipProvider,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { useColumnCustomizationStore } from '../store/columnCustomization.store';\nimport { ValueFormatterEditor } from '../editors/ValueFormatterEditor';\nimport { createExcelFormatter, getExcelStyleClass, createCellStyleFunction } from '@/components/datatable/utils/formatters';\nimport { hasConditionalStyling } from '@/components/datatable/utils/styleUtils';\nimport { \n  Hash, \n  DollarSign, \n  Percent, \n  Calendar, \n  Type, \n  Info, \n  HelpCircle,\n  Sparkles,\n  X,\n  AlertCircle\n} from 'lucide-react';\n\ninterface FormatTabProps {\n  uiMode?: 'simple' | 'advanced';\n}\n\n// Simplified format templates organized by category\nconst FORMAT_TEMPLATES = {\n  number: {\n    title: 'Numbers',\n    icon: Hash,\n    formats: [\n      { label: 'Number', format: '#,##0.00', preview: '1,234.56' },\n      { label: 'Integer', format: '#,##0', preview: '1,235' },\n      { label: 'No Separators', format: '0.00', preview: '1234.56' },\n      { label: '4 Decimals', format: '#,##0.0000', preview: '1,234.5600' },\n      { label: 'Positive/Negative Colors', format: '[>0][Green]#,##0.00;[<0][Red]#,##0.00;#,##0.00', preview: '1,234.56 / 1,234.56' },\n    ]\n  },\n  currency: {\n    title: 'Currency',\n    icon: DollarSign,\n    formats: [\n      { label: 'USD', format: '$#,##0.00', preview: '$1,234.56' },\n      { label: 'USD (Accounting)', format: '$#,##0.00;($#,##0.00)', preview: '($1,234.56)' },\n      { label: 'USD (Color)', format: '[>0][Green]$#,##0.00;[<0][Red]$#,##0.00;$#,##0.00', preview: '$1,234.56 / $1,234.56' },\n      { label: 'EUR', format: '€#,##0.00', preview: '€1,234.56' },\n      { label: 'GBP', format: '£#,##0.00', preview: '£1,234.56' },\n    ]\n  },\n  percentage: {\n    title: 'Percentage',\n    icon: Percent,\n    formats: [\n      { label: 'Percent', format: '0.00%', preview: '12.34%' },\n      { label: 'Percent (No Decimals)', format: '0%', preview: '12%' },\n      { label: 'Percent (Color)', format: '[>0][Green]0.00%;[<0][Red]0.00%;0.00%', preview: '12.34% / 12.34%' },\n      { label: 'Basis Points', format: '0 \"bps\"', preview: '1234 bps' },\n    ]\n  },\n  date: {\n    title: 'Date & Time',\n    icon: Calendar,\n    formats: [\n      { label: 'Short Date', format: 'MM/DD/YYYY', preview: '12/31/2023' },\n      { label: 'Long Date', format: 'MMMM D, YYYY', preview: 'December 31, 2023' },\n      { label: 'ISO Date', format: 'YYYY-MM-DD', preview: '2023-12-31' },\n      { label: 'Time', format: 'h:mm AM/PM', preview: '3:45 PM' },\n    ]\n  },\n  text: {\n    title: 'Text',\n    icon: Type,\n    formats: [\n      { label: 'Uppercase', format: '[Upper]', preview: 'EXAMPLE' },\n      { label: 'Lowercase', format: '[Lower]', preview: 'example' },\n      { label: 'Title Case', format: '[Title]', preview: 'Example Text' },\n    ]\n  }\n};\n\nexport function FormatTab({ uiMode = 'simple' }: FormatTabProps) {\n  const {\n    selectedColumns,\n    columnDefinitions,\n    pendingChanges,\n    updateBulkProperties,\n    updateSingleProperty,\n    updateBulkProperty,\n  } = useColumnCustomizationStore();\n\n  const [showFormatterEditor, setShowFormatterEditor] = useState(false);\n  const [selectedTemplate, setSelectedTemplate] = useState<string | null>(null);\n  const [customFormat, setCustomFormat] = useState('');\n  const [activeTab, setActiveTab] = useState('templates');\n\n  const isDisabled = selectedColumns.size === 0;\n  const isMultipleSelection = selectedColumns.size > 1;\n\n  // Get current format for single selection\n  const currentFormat = useMemo(() => {\n    if (selectedColumns.size !== 1) return null;\n    \n    const colId = Array.from(selectedColumns)[0];\n    const colDef = columnDefinitions.get(colId);\n    const pendingChange = pendingChanges.get(colId);\n    const formatter = pendingChange?.valueFormatter || colDef?.valueFormatter;\n    \n    if (formatter && typeof formatter === 'function') {\n      return (formatter as any).__formatString || null;\n    }\n    return null;\n  }, [selectedColumns, columnDefinitions, pendingChanges]);\n\n  // Apply format template\n  const applyFormat = useCallback(async (formatString: string) => {\n    if (!formatString || selectedColumns.size === 0) return;\n\n    try {\n      const formatter = createExcelFormatter(formatString);\n      const newFormatClasses = getExcelStyleClass(formatString);\n      \n      // Check if format string has conditional styling and create cellStyle if needed\n      console.log('[applyFormat] Checking if cellStyle needed for format:', formatString);\n      let cellStyle = undefined;\n      if (hasConditionalStyling(formatString)) {\n        console.log('[applyFormat] Creating cellStyle for conditional formatting');\n        \n        // Get existing base styles from ALL selected columns to preserve styling tab settings\n        // We need to check each column individually since they might have different styles\n        const cellStyleUpdates: Record<string, any> = {};\n        \n        selectedColumns.forEach(colId => {\n          const colDef = columnDefinitions.get(colId);\n          const pendingChange = pendingChanges.get(colId);\n          const existingCellStyle = pendingChange?.cellStyle || colDef?.cellStyle;\n          \n          let baseStyle: React.CSSProperties | undefined;\n          if (existingCellStyle) {\n            if (typeof existingCellStyle === 'object') {\n              // Direct style object from styling tab\n              baseStyle = existingCellStyle;\n            } else if (typeof existingCellStyle === 'function') {\n              // Function style - check for base style metadata\n              const metadata = (existingCellStyle as any).__baseStyle;\n              if (metadata) {\n                baseStyle = metadata;\n              } else {\n                // Try calling the function to see if it returns static styles\n                // This handles the case where styling tab created a function that returns static styles\n                const testStyle = existingCellStyle({ value: null });\n                if (testStyle && typeof testStyle === 'object') {\n                  baseStyle = testStyle;\n                }\n              }\n            }\n          }\n          \n          console.log(`[applyFormat] Column ${colId} base style:`, baseStyle);\n          cellStyleUpdates[colId] = createCellStyleFunction(formatString, baseStyle);\n        });\n        \n        // Check if all columns have the same base style\n        const uniqueStyles = new Set(Object.values(cellStyleUpdates).map(fn => {\n          const baseStyle = (fn as any).__baseStyle;\n          return baseStyle ? JSON.stringify(baseStyle) : 'undefined';\n        }));\n        \n        if (uniqueStyles.size === 1) {\n          // All columns have the same base style, use a single cellStyle function\n          cellStyle = Object.values(cellStyleUpdates)[0];\n        } else {\n          // Different base styles, we'll need to apply them individually\n          // Store for later individual application\n          properties.cellStyleUpdates = cellStyleUpdates;\n        }\n      }\n      \n      // Preserve existing alignment classes\n      const properties: any = {\n        valueFormatter: formatter,\n        useValueFormatterForExport: true\n      };\n      \n      if (cellStyle) {\n        properties.cellStyle = cellStyle;\n      }\n      \n      // Handle cellClass updates to preserve alignment\n      const cellClassUpdates: Record<string, string> = {};\n      selectedColumns.forEach(colId => {\n        const colDef = columnDefinitions.get(colId);\n        const pendingChange = pendingChanges.get(colId);\n        const existingCellClass = pendingChange?.cellClass || colDef?.cellClass || '';\n        \n        // Extract alignment classes from existing cellClass (both custom and Tailwind)\n        const existingClasses = existingCellClass.split(' ').filter(Boolean);\n        const alignmentClasses = existingClasses.filter((cls: string) => \n          // Custom alignment classes\n          cls.startsWith('cell-align-') || cls.startsWith('cell-valign-') ||\n          // Tailwind alignment classes\n          cls === 'text-left' || cls === 'text-center' || cls === 'text-right' ||\n          cls === 'justify-start' || cls === 'justify-center' || cls === 'justify-end' ||\n          cls === 'items-start' || cls === 'items-center' || cls === 'items-end'\n        );\n        \n        // Combine new format classes with preserved alignment classes\n        const allClasses = [...new Set([...newFormatClasses.split(' '), ...alignmentClasses])];\n        cellClassUpdates[colId] = allClasses.filter(Boolean).join(' ');\n      });\n      \n      // Apply cellClass\n      const uniqueCellClasses = new Set(Object.values(cellClassUpdates));\n      if (uniqueCellClasses.size === 1) {\n        properties.cellClass = Array.from(uniqueCellClasses)[0];\n      }\n      \n      // Apply properties\n      updateBulkProperties(properties);\n      \n      // Apply individual cellClass updates if needed\n      if (uniqueCellClasses.size > 1) {\n        selectedColumns.forEach(colId => {\n          updateSingleProperty(colId, 'cellClass', cellClassUpdates[colId]);\n        });\n      }\n      \n      // Apply individual cellStyle updates if needed\n      if (properties.cellStyleUpdates) {\n        selectedColumns.forEach(colId => {\n          updateSingleProperty(colId, 'cellStyle', properties.cellStyleUpdates[colId]);\n        });\n        delete properties.cellStyleUpdates; // Clean up\n      }\n      \n      setSelectedTemplate(formatString);\n    } catch (error) {\n      console.error('Error applying format:', error);\n    }\n  }, [selectedColumns, updateBulkProperties, updateSingleProperty, columnDefinitions, pendingChanges]);\n\n  // Clear format\n  const clearFormat = useCallback(() => {\n    if (selectedColumns.size === 0) return;\n    \n    // Preserve alignment classes when clearing format\n    const cellClassUpdates: Record<string, string | undefined> = {};\n    selectedColumns.forEach(colId => {\n      const colDef = columnDefinitions.get(colId);\n      const pendingChange = pendingChanges.get(colId);\n      const existingCellClass = pendingChange?.cellClass || colDef?.cellClass || '';\n      \n      // Extract only alignment classes to preserve (both custom and Tailwind)\n      const alignmentClasses = existingCellClass.split(' ').filter((cls: string) => \n        // Custom alignment classes\n        cls.startsWith('cell-align-') || cls.startsWith('cell-valign-') ||\n        // Tailwind alignment classes\n        cls === 'text-left' || cls === 'text-center' || cls === 'text-right' ||\n        cls === 'justify-start' || cls === 'justify-center' || cls === 'justify-end' ||\n        cls === 'items-start' || cls === 'items-center' || cls === 'items-end'\n      );\n      \n      cellClassUpdates[colId] = alignmentClasses.length > 0 ? alignmentClasses.join(' ') : undefined;\n    });\n    \n    const properties: any = {\n      valueFormatter: undefined,\n      cellStyle: undefined\n    };\n    \n    // Handle cellClass updates\n    const uniqueCellClasses = new Set(Object.values(cellClassUpdates));\n    if (uniqueCellClasses.size === 1) {\n      properties.cellClass = Array.from(uniqueCellClasses)[0];\n    }\n    \n    updateBulkProperties(properties);\n    \n    // Apply individual cellClass updates if needed\n    if (uniqueCellClasses.size > 1) {\n      selectedColumns.forEach(colId => {\n        updateSingleProperty(colId, 'cellClass', cellClassUpdates[colId]);\n      });\n    }\n    \n    setSelectedTemplate(null);\n    setCustomFormat('');\n  }, [selectedColumns, updateBulkProperties, updateSingleProperty, columnDefinitions, pendingChanges]);\n\n  // Handle custom format input\n  const handleCustomFormatApply = useCallback(() => {\n    if (customFormat.trim()) {\n      applyFormat(customFormat.trim());\n    }\n  }, [customFormat, applyFormat]);\n\n  // Check if current format matches a template\n  const isTemplateSelected = useCallback((format: string) => {\n    return currentFormat === format || selectedTemplate === format;\n  }, [currentFormat, selectedTemplate]);\n\n  if (isDisabled) {\n    return (\n      <div className=\"p-6 text-center text-muted-foreground\">\n        <Info className=\"h-12 w-12 mx-auto mb-3 opacity-50\" />\n        <p>Select one or more columns to apply formatting</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"p-4 space-y-4\">\n      {/* Header with guidance */}\n      <div className=\"space-y-2\">\n        <div className=\"flex items-center justify-between\">\n          <h3 className=\"text-lg font-medium\">Format Cells</h3>\n          {currentFormat && (\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={clearFormat}\n              className=\"h-8 text-xs\"\n            >\n              <X className=\"h-3 w-3 mr-1\" />\n              Clear Format\n            </Button>\n          )}\n        </div>\n        <p className=\"text-sm text-muted-foreground\">\n          Choose how to display values in the selected {isMultipleSelection ? 'columns' : 'column'}\n        </p>\n      </div>\n\n      <Separator />\n\n      {/* Current format display */}\n      {currentFormat && !isMultipleSelection && (\n        <Alert className=\"py-2\">\n          <AlertCircle className=\"h-4 w-4\" />\n          <AlertDescription className=\"text-sm\">\n            Current format: <code className=\"ml-1 px-2 py-0.5 bg-muted rounded text-xs\">{currentFormat}</code>\n          </AlertDescription>\n        </Alert>\n      )}\n\n      {/* Format options */}\n      <Tabs value={activeTab} onValueChange={setActiveTab} className=\"space-y-4\">\n        <TabsList className=\"grid w-full grid-cols-3\">\n          <TabsTrigger value=\"templates\">Templates</TabsTrigger>\n          <TabsTrigger value=\"custom\">Custom Format</TabsTrigger>\n          <TabsTrigger value=\"advanced\">Advanced</TabsTrigger>\n        </TabsList>\n\n        {/* Templates Tab */}\n        <TabsContent value=\"templates\" className=\"space-y-4\">\n          <ScrollArea className=\"h-[400px] pr-4\">\n            <div className=\"space-y-6\">\n              {Object.entries(FORMAT_TEMPLATES).map(([key, category]) => {\n                const Icon = category.icon;\n                return (\n                  <div key={key} className=\"space-y-3\">\n                    <div className=\"flex items-center gap-2\">\n                      <Icon className=\"h-4 w-4 text-muted-foreground\" />\n                      <h4 className=\"font-medium text-sm\">{category.title}</h4>\n                    </div>\n                    <div className=\"grid gap-2\">\n                      {category.formats.map((format) => (\n                        <Card\n                          key={format.format}\n                          className={`cursor-pointer transition-colors ${\n                            isTemplateSelected(format.format) \n                              ? 'border-primary bg-primary/5' \n                              : 'hover:border-muted-foreground/50'\n                          }`}\n                          onClick={() => applyFormat(format.format)}\n                        >\n                          <CardContent className=\"p-3\">\n                            <div className=\"flex items-center justify-between\">\n                              <div className=\"space-y-1\">\n                                <p className=\"text-sm font-medium\">{format.label}</p>\n                                <p className=\"text-xs text-muted-foreground font-mono\">\n                                  {format.format}\n                                </p>\n                              </div>\n                              <div className=\"text-right\">\n                                <p className=\"text-sm font-mono text-muted-foreground\">\n                                  {format.preview}\n                                </p>\n                              </div>\n                            </div>\n                          </CardContent>\n                        </Card>\n                      ))}\n                    </div>\n                  </div>\n                );\n              })}\n            </div>\n          </ScrollArea>\n        </TabsContent>\n\n        {/* Custom Format Tab */}\n        <TabsContent value=\"custom\" className=\"space-y-4\">\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"text-base\">Custom Format String</CardTitle>\n              <CardDescription>\n                Enter an Excel-style format string\n              </CardDescription>\n            </CardHeader>\n            <CardContent className=\"space-y-4\">\n              <div className=\"space-y-2\">\n                <Label htmlFor=\"custom-format\">Format String</Label>\n                <div className=\"flex gap-2\">\n                  <Input\n                    id=\"custom-format\"\n                    value={customFormat}\n                    onChange={(e) => setCustomFormat(e.target.value)}\n                    placeholder='e.g., #,##0.00 or \"USD\" #,##0.00'\n                    className=\"font-mono text-sm\"\n                  />\n                  <Button \n                    onClick={handleCustomFormatApply}\n                    disabled={!customFormat.trim()}\n                    size=\"sm\"\n                  >\n                    Apply\n                  </Button>\n                </div>\n              </div>\n\n              {/* Format string examples */}\n              <div className=\"space-y-2\">\n                <p className=\"text-sm font-medium text-muted-foreground\">Examples:</p>\n                <div className=\"space-y-1 text-xs text-muted-foreground\">\n                  <div className=\"flex justify-between font-mono\">\n                    <span>#,##0.00</span>\n                    <span>→ 1,234.56</span>\n                  </div>\n                  <div className=\"flex justify-between font-mono\">\n                    <span>0.00%</span>\n                    <span>→ 12.34%</span>\n                  </div>\n                  <div className=\"flex justify-between font-mono\">\n                    <span>\"USD\" #,##0.00</span>\n                    <span>→ USD 1,234.56</span>\n                  </div>\n                  <div className=\"flex justify-between font-mono\">\n                    <span>MM/DD/YYYY</span>\n                    <span>→ 12/31/2023</span>\n                  </div>\n                </div>\n              </div>\n\n              {/* Help tooltip */}\n              <Alert>\n                <HelpCircle className=\"h-4 w-4\" />\n                <AlertDescription className=\"text-xs\">\n                  <strong>Format symbols:</strong>\n                  <br />\n                  # = Optional digit, 0 = Required digit, , = Thousand separator\n                  <br />\n                  . = Decimal point, % = Percentage, $ = Currency\n                  <br />\n                  \"text\" = Literal text, _ = Space, * = Fill character\n                </AlertDescription>\n              </Alert>\n            </CardContent>\n          </Card>\n        </TabsContent>\n\n        {/* Advanced Tab */}\n        <TabsContent value=\"advanced\" className=\"space-y-4\">\n          <Card>\n            <CardHeader>\n              <CardTitle className=\"text-base\">Advanced Formatting</CardTitle>\n              <CardDescription>\n                Create conditional formatting with rules and styles\n              </CardDescription>\n            </CardHeader>\n            <CardContent>\n              <Button\n                onClick={() => setShowFormatterEditor(true)}\n                variant=\"outline\"\n                className=\"w-full\"\n              >\n                <Sparkles className=\"h-4 w-4 mr-2\" />\n                Open Advanced Editor\n              </Button>\n            </CardContent>\n          </Card>\n\n          <Alert>\n            <Info className=\"h-4 w-4\" />\n            <AlertDescription className=\"text-sm\">\n              The advanced editor allows you to create complex conditional formatting rules with:\n              <ul className=\"mt-2 ml-4 list-disc text-xs space-y-1\">\n                <li>Multiple conditions (if value {'>'} X, if value {'<'} Y, etc.)</li>\n                <li>Custom colors and styles for each condition</li>\n                <li>Text transformations and custom display formats</li>\n                <li>Default fallback formatting</li>\n              </ul>\n            </AlertDescription>\n          </Alert>\n        </TabsContent>\n      </Tabs>\n\n      {/* Advanced formatter dialog */}\n      {showFormatterEditor && (\n        <ValueFormatterEditor\n          open={showFormatterEditor}\n          onOpenChange={setShowFormatterEditor}\n          initialFormatter={(() => {\n            if (selectedColumns.size !== 1) return undefined;\n            const colId = Array.from(selectedColumns)[0];\n            const colDef = columnDefinitions.get(colId);\n            const pendingChange = pendingChanges.get(colId);\n            return pendingChange?.valueFormatter || colDef?.valueFormatter;\n          })()}\n          onSave={async (formatter, cellStyle) => {\n            console.log('[FormatTab] Received from ValueFormatterEditor:', {\n              hasFormatter: !!formatter,\n              formatterType: typeof formatter,\n              formatString: (formatter as any)?.__formatString,\n              hasCellStyle: !!cellStyle,\n              cellStyleType: typeof cellStyle\n            });\n            \n            const properties: any = {\n              valueFormatter: formatter,\n              useValueFormatterForExport: true\n            };\n            \n            if (cellStyle) {\n              // We need to check each selected column for existing base styles\n              const cellStyleUpdates: Record<string, any> = {};\n              const formatString = (formatter as any).__formatString;\n              \n              selectedColumns.forEach(colId => {\n                const colDef = columnDefinitions.get(colId);\n                const pendingChange = pendingChanges.get(colId);\n                const existingCellStyle = pendingChange?.cellStyle || colDef?.cellStyle;\n                \n                let baseStyle: React.CSSProperties | undefined;\n                if (existingCellStyle) {\n                  if (typeof existingCellStyle === 'object') {\n                    // Direct style object from styling tab\n                    baseStyle = existingCellStyle;\n                  } else if (typeof existingCellStyle === 'function') {\n                    // Function style - check for base style metadata\n                    const metadata = (existingCellStyle as any).__baseStyle;\n                    if (metadata) {\n                      baseStyle = metadata;\n                    } else {\n                      // Try calling the function to see if it returns static styles\n                      const testStyle = existingCellStyle({ value: null });\n                      if (testStyle && typeof testStyle === 'object') {\n                        baseStyle = testStyle;\n                      }\n                    }\n                  }\n                }\n                \n                console.log(`[FormatTab] Column ${colId} existing base style:`, baseStyle);\n                \n                // Create a merged cellStyle function that preserves base styles\n                if (baseStyle && Object.keys(baseStyle).length > 0) {\n                  const mergedCellStyle = (params: { value: unknown }) => {\n                    const conditionalStyles = cellStyle(params) || {};\n                    // Always merge base and conditional styles, with conditional taking precedence\n                    const merged = { ...baseStyle, ...conditionalStyles };\n                    return Object.keys(merged).length > 0 ? merged : undefined;\n                  };\n                  \n                  // Attach metadata\n                  if (formatString) {\n                    Object.defineProperty(mergedCellStyle, '__formatString', { \n                      value: formatString,\n                      writable: false,\n                      enumerable: false,\n                      configurable: true\n                    });\n                  }\n                  Object.defineProperty(mergedCellStyle, '__baseStyle', { \n                    value: baseStyle,\n                    writable: false,\n                    enumerable: false,\n                    configurable: true\n                  });\n                  \n                  cellStyleUpdates[colId] = mergedCellStyle;\n                } else {\n                  // No base styles, use the cellStyle as-is\n                  cellStyleUpdates[colId] = cellStyle;\n                }\n              });\n              \n              // Check if all columns have the same cellStyle function\n              const uniqueStyles = new Set(Object.values(cellStyleUpdates).map(fn => {\n                const baseStyle = (fn as any).__baseStyle;\n                const formatString = (fn as any).__formatString;\n                return JSON.stringify({ baseStyle, formatString });\n              }));\n              \n              if (uniqueStyles.size === 1) {\n                // All columns have the same style function, use bulk update\n                properties.cellStyle = Object.values(cellStyleUpdates)[0];\n              } else {\n                // Different styles, need individual updates\n                properties.cellStyleUpdates = cellStyleUpdates;\n              }\n            }\n            \n            console.log('[FormatTab] Updating bulk properties:', properties);\n            updateBulkProperties(properties);\n            \n            // Apply individual cellStyle updates if needed\n            if (properties.cellStyleUpdates) {\n              selectedColumns.forEach(colId => {\n                updateSingleProperty(colId, 'cellStyle', properties.cellStyleUpdates[colId]);\n              });\n              delete properties.cellStyleUpdates; // Clean up\n            }\n            \n            setShowFormatterEditor(false);\n          }}\n          dataType={(() => {\n            if (selectedColumns.size === 0) return 'text';\n            const colId = Array.from(selectedColumns)[0];\n            const colDef = columnDefinitions.get(colId);\n            return colDef?.cellDataType as string || 'text';\n          })()}\n        />\n      )}\n    </div>\n  );\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/tabs/GeneralTab.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/tabs/StylingTab.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":70,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2838,2841],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2838,2841],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":83,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3654,3657],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3654,3657],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":176,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7429,7432],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7429,7432],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":277,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":277,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11740,11743],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11740,11743],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { ScrollArea } from '@/components/ui/scroll-area';\nimport { ThreeStateCheckbox } from '../components/ThreeStateCheckbox';\nimport { AlignmentIconPicker } from '../components/AlignmentIconPicker';\nimport { Button } from '@/components/ui/button';\nimport { Palette, Eraser } from 'lucide-react';\nimport { StyleEditor } from '../editors/StyleEditor';\nimport { useColumnCustomizationStore } from '../store/columnCustomization.store';\nimport { createCellStyleFunction } from '@/components/datatable/utils/formatters';\n\ninterface StylingTabProps {\n  uiMode?: 'simple' | 'advanced';\n}\n\nexport const StylingTab: React.FC<StylingTabProps> = ({ uiMode: _uiMode = 'simple' }) => {\n  const {\n    selectedColumns,\n    columnDefinitions,\n    pendingChanges,\n    updateBulkProperty\n  } = useColumnCustomizationStore();\n\n  const [showCellStyleEditor, setShowCellStyleEditor] = useState(false);\n  const [showHeaderStyleEditor, setShowHeaderStyleEditor] = useState(false);\n\n  const getMixedValue = (property: string) => {\n    const values = new Set();\n    const allValues: unknown[] = [];\n\n    selectedColumns.forEach(colId => {\n      const colDef = columnDefinitions.get(colId);\n      const pendingChange = pendingChanges.get(colId);\n\n      // Check pending changes first, then fall back to column definition\n      let value;\n      if (pendingChange && property in pendingChange) {\n        value = pendingChange[property as keyof typeof pendingChange];\n      } else if (colDef) {\n        value = colDef[property as keyof typeof colDef];\n      }\n\n      values.add(value);\n      allValues.push(value);\n    });\n\n    if (values.size === 0) return { value: undefined, isMixed: false };\n    if (values.size === 1) return { value: Array.from(values)[0], isMixed: false };\n    return { value: undefined, isMixed: true, values: allValues };\n  };\n\n  const isDisabled = selectedColumns.size === 0;\n  const isMultipleSelection = selectedColumns.size > 1;\n\n  const handleCellStyleSave = (style: React.CSSProperties) => {\n    // Check if we have conditional formatting that needs to be preserved\n    let hasConditionalFormatting = false;\n    let formatString = '';\n    \n    selectedColumns.forEach(colId => {\n      const colDef = columnDefinitions.get(colId);\n      const pendingChange = pendingChanges.get(colId);\n      \n      // Check pending changes first, then column definition\n      const valueFormatter = pendingChange?.valueFormatter || colDef?.valueFormatter;\n      const cellStyle = pendingChange?.cellStyle || colDef?.cellStyle;\n      \n      // First check if valueFormatter has format string metadata\n      if (valueFormatter && typeof valueFormatter === 'function') {\n        const metadata = (valueFormatter as any).__formatString;\n        if (metadata && metadata.includes('[') && metadata.includes(']')) {\n          // Check if format string contains style directives OR color specifications\n          const hasStyleDirectives = metadata.match(/\\[(BG:|Background:|Border:|B:|Size:|FontSize:|Align:|TextAlign:|Padding:|P:|Weight:|FontWeight:|Bold|Italic|Underline|Center|Left|Right|#[0-9A-Fa-f]{3,6}|Red|Green|Blue|Yellow|Orange|Purple|Gray|Grey|Black|White|Magenta|Cyan)/i);\n          if (hasStyleDirectives) {\n            hasConditionalFormatting = true;\n            formatString = metadata;\n          }\n        }\n      }\n      \n      // Also check if existing cellStyle has format string metadata\n      if (!hasConditionalFormatting && cellStyle && typeof cellStyle === 'function') {\n        const metadata = (cellStyle as any).__formatString;\n        if (metadata && metadata.includes('[') && metadata.includes(']')) {\n          hasConditionalFormatting = true;\n          formatString = metadata;\n        }\n      }\n    });\n    \n    if (hasConditionalFormatting) {\n      // We have conditional formatting from valueFormatter\n      // Create a cellStyle function that merges base styles with conditional styles\n      // Conditional styles take precedence (similar to the reference implementation)\n      // Create a custom cellStyle function that always merges base and conditional styles\n      // This is different from createCellStyleFunction which returns EITHER conditional OR base styles\n      const cellStyleFn = (params: { value: unknown }) => {\n        // Always start with base styles\n        const baseStyles = style && Object.keys(style).length > 0 ? { ...style } : {};\n        \n        // Get conditional styles using createCellStyleFunction with empty base\n        // This ensures we only get the conditional styles when conditions match\n        const conditionalStyleFn = createCellStyleFunction(formatString, {});\n        const conditionalStyles = conditionalStyleFn(params) || {};\n        \n        // Always merge base and conditional styles, with conditional taking precedence\n        // This matches the reference implementation pattern\n        const mergedStyles = { ...baseStyles, ...conditionalStyles };\n        \n        // Return merged styles if we have any, otherwise undefined\n        return Object.keys(mergedStyles).length > 0 ? mergedStyles : undefined;\n      };\n      \n      // Attach metadata for future serialization\n      Object.defineProperty(cellStyleFn, '__formatString', { \n        value: formatString, \n        writable: false,\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(cellStyleFn, '__baseStyle', { \n        value: style, \n        writable: false,\n        enumerable: false,\n        configurable: true\n      });\n      updateBulkProperty('cellStyle', cellStyleFn);\n    } else {\n      // No conditional formatting, just save the style directly\n      updateBulkProperty('cellStyle', style);\n    }\n  };\n\n  const handleHeaderStyleSave = (style: React.CSSProperties) => {\n    console.log('[StylingTab] Saving headerStyle:', {\n      style,\n      selectedColumnsCount: selectedColumns.size,\n      selectedColumns: Array.from(selectedColumns)\n    });\n    \n    // Create a function that applies styles only to regular headers, not floating filters\n    const headerStyleFn = (params: { floatingFilter?: boolean }) => {\n      // Don't apply styles to floating filter row\n      if (params?.floatingFilter) {\n        return null;\n      }\n      return style;\n    };\n    \n    updateBulkProperty('headerStyle', headerStyleFn);\n  };\n\n  // Clear all styles\n  const _clearAllStyles = () => {\n    updateBulkProperty('cellStyle', undefined);\n    updateBulkProperty('headerStyle', undefined);\n    updateBulkProperty('cellClass', undefined);\n    updateBulkProperty('headerClass', undefined);\n  };\n\n  // Clear only cell styles\n  const clearCellStyles = () => {\n    // Check if we have conditional formatting from valueFormatter that needs to be preserved\n    let hasConditionalFormatting = false;\n    let formatString = '';\n    \n    selectedColumns.forEach(colId => {\n      const colDef = columnDefinitions.get(colId);\n      const pendingChange = pendingChanges.get(colId);\n      \n      // Check pending changes first, then column definition\n      const valueFormatter = pendingChange?.valueFormatter || colDef?.valueFormatter;\n      \n      // Check if valueFormatter has format string metadata (from conditional formatting)\n      if (valueFormatter && typeof valueFormatter === 'function') {\n        const metadata = (valueFormatter as any).__formatString;\n        if (metadata && metadata.includes('[') && metadata.includes(']')) {\n          // Check if format string contains style directives OR color specifications\n          const hasStyleDirectives = metadata.match(/\\[(BG:|Background:|Border:|B:|Size:|FontSize:|Align:|TextAlign:|Padding:|P:|Weight:|FontWeight:|Bold|Italic|Underline|Center|Left|Right|#[0-9A-Fa-f]{3,6}|Red|Green|Blue|Yellow|Orange|Purple|Gray|Grey|Black|White|Magenta|Cyan)/i);\n          if (hasStyleDirectives) {\n            hasConditionalFormatting = true;\n            formatString = metadata;\n          }\n        }\n      }\n    });\n    \n    if (hasConditionalFormatting) {\n      // Keep conditional formatting but clear base styles\n      // This is the same as handleCellStyleSave but with empty base styles\n      const cellStyleFn = (params: { value: unknown }) => {\n        // No base styles (cleared)\n        const _baseStyles = {};\n        \n        // Get conditional styles using createCellStyleFunction with empty base\n        const conditionalStyleFn = createCellStyleFunction(formatString, {});\n        const conditionalStyles = conditionalStyleFn(params) || {};\n        \n        // Return only conditional styles since base styles are cleared\n        return Object.keys(conditionalStyles).length > 0 ? conditionalStyles : undefined;\n      };\n      \n      // Attach metadata for future serialization\n      Object.defineProperty(cellStyleFn, '__formatString', { \n        value: formatString, \n        writable: false,\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(cellStyleFn, '__baseStyle', { \n        value: {}, \n        writable: false,\n        enumerable: false,\n        configurable: true\n      });\n      updateBulkProperty('cellStyle', cellStyleFn);\n    } else {\n      updateBulkProperty('cellStyle', undefined);\n    }\n    \n    // Clear non-format related classes\n    const currentCellClass = getMixedValue('cellClass');\n    if (currentCellClass.value) {\n      const classes = (currentCellClass.value as string).split(' ').filter(c => \n        c.startsWith('ag-numeric-cell') || c.startsWith('ag-currency-cell') || \n        c.startsWith('ag-percentage-cell') || c.startsWith('ag-date-cell')\n      );\n      updateBulkProperty('cellClass', classes.length > 0 ? classes.join(' ') : undefined);\n    }\n  };\n\n  // Clear only header styles\n  const clearHeaderStyles = () => {\n    updateBulkProperty('headerStyle', undefined);\n    updateBulkProperty('headerClass', undefined);\n  };\n\n  // Clear only alignment classes (keep other styles)\n  const _clearAlignment = () => {\n    const currentHeaderClass = getMixedValue('headerClass');\n    const currentCellClass = getMixedValue('cellClass');\n\n    // Remove alignment classes from headerClass\n    if (currentHeaderClass.value) {\n      const headerClasses = (currentHeaderClass.value as string).split(' ').filter(c =>\n        !c.startsWith('header-align-') && !c.startsWith('header-valign-')\n      );\n      updateBulkProperty('headerClass', headerClasses.length > 0 ? headerClasses.join(' ') : undefined);\n    }\n\n    // Remove alignment classes from cellClass\n    if (currentCellClass.value) {\n      const cellClasses = (currentCellClass.value as string).split(' ').filter(c =>\n        !c.startsWith('cell-align-') && !c.startsWith('cell-valign-')\n      );\n      updateBulkProperty('cellClass', cellClasses.length > 0 ? cellClasses.join(' ') : undefined);\n    }\n  };\n\n  // Get current cell style (if consistent across selected columns)\n  const currentCellStyle = getMixedValue('cellStyle');\n  const currentHeaderStyle = getMixedValue('headerStyle');\n  \n  // Extract style object from headerStyle if it's a function\n  const getHeaderStyleObject = () => {\n    if (currentHeaderStyle.value && typeof currentHeaderStyle.value === 'function') {\n      // Call the function with non-floating filter context to get the style object\n      return currentHeaderStyle.value({ floatingFilter: false });\n    }\n    return currentHeaderStyle.value;\n  };\n\n  // Extract style object from cellStyle if it's a function\n  const getCellStyleObject = () => {\n    if (currentCellStyle.value && typeof currentCellStyle.value === 'function') {\n      // Check if this function has base style metadata\n      const baseStyle = (currentCellStyle.value as any).__baseStyle;\n      if (baseStyle) {\n        return baseStyle;\n      }\n      // Don't pass function-based styles to the editor without base style\n      return {};\n    }\n    return currentCellStyle.value;\n  };\n\n  // Handle header alignment changes using headerClass (separate from headerStyle)\n  const handleHeaderAlignmentChange = (alignment: string, type: 'horizontal' | 'vertical') => {\n    const currentHeaderClass = getMixedValue('headerClass');\n    // Ensure we always work with strings, not booleans\n    const currentClassesRaw = currentHeaderClass.value;\n    const currentClasses = (typeof currentClassesRaw === 'string' ? currentClassesRaw : '').trim();\n    const classArray = currentClasses ? currentClasses.split(' ').filter(c => c) : [];\n\n    // Remove existing alignment classes (both custom and Tailwind)\n    const filteredClasses = classArray.filter(c => {\n      if (type === 'horizontal') {\n        return !c.startsWith('header-align-') && \n               c !== 'text-left' && c !== 'text-center' && c !== 'text-right' &&\n               c !== 'justify-start' && c !== 'justify-center' && c !== 'justify-end';\n      } else {\n        return !c.startsWith('header-valign-') &&\n               c !== 'items-start' && c !== 'items-center' && c !== 'items-end';\n      }\n    });\n\n    // Add new Tailwind alignment classes if not default\n    if (alignment !== 'default') {\n      if (type === 'horizontal') {\n        // For headers, we need both text alignment and flex justification\n        const alignmentMap: Record<string, string[]> = {\n          'left': ['text-left', 'justify-start'],\n          'center': ['text-center', 'justify-center'],\n          'right': ['text-right', 'justify-end']\n        };\n        if (alignmentMap[alignment]) {\n          filteredClasses.push(...alignmentMap[alignment]);\n        }\n      } else {\n        // Vertical alignment\n        const alignmentMap: Record<string, string> = {\n          'top': 'items-start',\n          'middle': 'items-center',\n          'bottom': 'items-end'\n        };\n        if (alignmentMap[alignment]) {\n          filteredClasses.push(alignmentMap[alignment]);\n        }\n      }\n    }\n\n    const newHeaderClass = filteredClasses.join(' ').trim();\n    updateBulkProperty('headerClass', newHeaderClass || undefined);\n  };\n\n  // Handle cell alignment changes using cellClass\n  const handleCellAlignmentChange = (alignment: string, type: 'horizontal' | 'vertical') => {\n    const currentCellClass = getMixedValue('cellClass');\n    // Ensure we always work with strings, not booleans\n    const currentClassesRaw = currentCellClass.value;\n    const currentClasses = (typeof currentClassesRaw === 'string' ? currentClassesRaw : '').trim();\n    const classArray = currentClasses ? currentClasses.split(' ').filter(c => c) : [];\n\n    // Remove existing alignment classes (both custom and Tailwind)\n    const filteredClasses = classArray.filter(c => {\n      if (type === 'horizontal') {\n        return !c.startsWith('cell-align-') && \n               c !== 'text-left' && c !== 'text-center' && c !== 'text-right' &&\n               c !== 'justify-start' && c !== 'justify-center' && c !== 'justify-end';\n      } else {\n        return !c.startsWith('cell-valign-') &&\n               c !== 'items-start' && c !== 'items-center' && c !== 'items-end';\n      }\n    });\n\n    // Add new Tailwind alignment classes if not default\n    if (alignment !== 'default') {\n      if (type === 'horizontal') {\n        // For cells, we need both text alignment and flex justification\n        const alignmentMap: Record<string, string[]> = {\n          'left': ['text-left', 'justify-start'],\n          'center': ['text-center', 'justify-center'],\n          'right': ['text-right', 'justify-end']\n        };\n        if (alignmentMap[alignment]) {\n          filteredClasses.push(...alignmentMap[alignment]);\n        }\n      } else {\n        // Vertical alignment\n        const alignmentMap: Record<string, string> = {\n          'top': 'items-start',\n          'middle': 'items-center',\n          'bottom': 'items-end'\n        };\n        if (alignmentMap[alignment]) {\n          filteredClasses.push(alignmentMap[alignment]);\n        }\n      }\n    }\n\n    const newCellClass = filteredClasses.join(' ').trim();\n    updateBulkProperty('cellClass', newCellClass || undefined);\n  };\n\n  // Extract current header alignment from headerClass\n  const getCurrentHeaderAlignment = (type: 'horizontal' | 'vertical') => {\n    const headerClassValue = getMixedValue('headerClass');\n    const headerClassRaw = headerClassValue.value;\n    const headerClass = (typeof headerClassRaw === 'string' ? headerClassRaw : '').trim();\n\n    if (!headerClass) return 'default';\n\n    if (type === 'horizontal') {\n      // Check for Tailwind classes first\n      if (headerClass.includes('text-left') || headerClass.includes('justify-start')) return 'left';\n      if (headerClass.includes('text-center') || headerClass.includes('justify-center')) return 'center';\n      if (headerClass.includes('text-right') || headerClass.includes('justify-end')) return 'right';\n      \n      // Fall back to custom classes\n      const prefix = 'header-align-';\n      const regex = new RegExp(`${prefix}(\\\\w+)`);\n      const match = headerClass.match(regex);\n      return match ? match[1] : 'default';\n    } else {\n      // Check for Tailwind classes\n      if (headerClass.includes('items-start')) return 'top';\n      if (headerClass.includes('items-center')) return 'middle';\n      if (headerClass.includes('items-end')) return 'bottom';\n      \n      // Fall back to custom classes\n      const prefix = 'header-valign-';\n      const regex = new RegExp(`${prefix}(\\\\w+)`);\n      const match = headerClass.match(regex);\n      return match ? match[1] : 'default';\n    }\n  };\n\n  // Extract current cell alignment from cellClass\n  const getCurrentCellAlignment = (type: 'horizontal' | 'vertical') => {\n    const cellClassValue = getMixedValue('cellClass');\n    const cellClassRaw = cellClassValue.value;\n    const cellClass = (typeof cellClassRaw === 'string' ? cellClassRaw : '').trim();\n\n    if (!cellClass) return 'default';\n\n    if (type === 'horizontal') {\n      // Check for Tailwind classes first\n      if (cellClass.includes('text-left') || cellClass.includes('justify-start')) return 'left';\n      if (cellClass.includes('text-center') || cellClass.includes('justify-center')) return 'center';\n      if (cellClass.includes('text-right') || cellClass.includes('justify-end')) return 'right';\n      \n      // Fall back to custom classes\n      const prefix = 'cell-align-';\n      const regex = new RegExp(`${prefix}(\\\\w+)`);\n      const match = cellClass.match(regex);\n      return match ? match[1] : 'default';\n    } else {\n      // Check for Tailwind classes\n      if (cellClass.includes('items-start')) return 'top';\n      if (cellClass.includes('items-center')) return 'middle';\n      if (cellClass.includes('items-end')) return 'bottom';\n      \n      // Fall back to custom classes\n      const prefix = 'cell-valign-';\n      const regex = new RegExp(`${prefix}(\\\\w+)`);\n      const match = cellClass.match(regex);\n      return match ? match[1] : 'default';\n    }\n  };\n\n  // Check if header alignment is mixed\n  const isHeaderAlignmentMixed = (_type: 'horizontal' | 'vertical') => {\n    const headerClassValue = getMixedValue('headerClass');\n    return headerClassValue.isMixed;\n  };\n\n  // Check if cell alignment is mixed\n  const isCellAlignmentMixed = (_type: 'horizontal' | 'vertical') => {\n    const cellClassValue = getMixedValue('cellClass');\n    return cellClassValue.isMixed;\n  };\n\n  return (\n    <ScrollArea className=\"h-full\">\n      <div className=\"px-6 py-4 space-y-6\">\n        {/* Two-column layout for better space utilization */}\n        <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6\">\n          {/* Left Column */}\n          <div className=\"space-y-6\">\n            {/* Header Alignment */}\n            <Card>\n              <CardHeader className=\"pb-3\">\n                <CardTitle className=\"text-base\">Header Alignment</CardTitle>\n                <CardDescription className=\"text-sm\">\n                  Set text alignment for column headers\n                </CardDescription>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <AlignmentIconPicker\n                  label=\"Horizontal\"\n                  type=\"horizontal\"\n                  value={getCurrentHeaderAlignment('horizontal')}\n                  onChange={(value) => handleHeaderAlignmentChange(value, 'horizontal')}\n                  disabled={isDisabled || (isMultipleSelection && isHeaderAlignmentMixed('horizontal'))}\n                  isMixed={isMultipleSelection && isHeaderAlignmentMixed('horizontal')}\n                />\n\n                <AlignmentIconPicker\n                  label=\"Vertical\"\n                  type=\"vertical\"\n                  value={getCurrentHeaderAlignment('vertical')}\n                  onChange={(value) => handleHeaderAlignmentChange(value, 'vertical')}\n                  disabled={isDisabled || (isMultipleSelection && isHeaderAlignmentMixed('vertical'))}\n                  isMixed={isMultipleSelection && isHeaderAlignmentMixed('vertical')}\n                />\n              </CardContent>\n            </Card>\n\n            {/* Style Editors */}\n            <Card>\n              <CardHeader className=\"pb-3\">\n                <CardTitle className=\"text-base\">Style Editors</CardTitle>\n                <CardDescription className=\"text-sm\">\n                  Customize visual appearance\n                </CardDescription>\n              </CardHeader>\n              <CardContent className=\"space-y-3\">\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  className=\"w-full justify-start gap-2 h-9\"\n                  disabled={isDisabled}\n                  onClick={() => setShowHeaderStyleEditor(true)}\n                >\n                  <Palette className=\"h-4 w-4\" />\n                  Edit Header Style\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  className=\"w-full justify-start gap-2 h-9\"\n                  disabled={isDisabled}\n                  onClick={() => setShowCellStyleEditor(true)}\n                >\n                  <Palette className=\"h-4 w-4\" />\n                  Edit Cell Style\n                </Button>\n              </CardContent>\n            </Card>\n\n            {/* Text Display Options */}\n            <Card>\n              <CardHeader className=\"pb-3\">\n                <CardTitle className=\"text-base\">Text Display</CardTitle>\n                <CardDescription className=\"text-sm\">\n                  Control how text is displayed in cells\n                </CardDescription>\n              </CardHeader>\n              <CardContent className=\"space-y-3\">\n                <ThreeStateCheckbox\n                  label=\"Wrap Text\"\n                  property=\"wrapText\"\n                  mixedValue={getMixedValue('wrapText')}\n                  onChange={(value) => updateBulkProperty('wrapText', value)}\n                  disabled={isDisabled || (isMultipleSelection && getMixedValue('wrapText').isMixed)}\n                  description=\"Wrap long text within cells\"\n                />\n\n                <ThreeStateCheckbox\n                  label=\"Auto Height\"\n                  property=\"autoHeight\"\n                  mixedValue={getMixedValue('autoHeight')}\n                  onChange={(value) => updateBulkProperty('autoHeight', value)}\n                  disabled={isDisabled || (isMultipleSelection && getMixedValue('autoHeight').isMixed)}\n                  description=\"Automatically adjust row height to fit content\"\n                />\n              </CardContent>\n            </Card>\n          </div>\n\n          {/* Right Column */}\n          <div className=\"space-y-6\">\n            {/* Cell Alignment */}\n            <Card>\n              <CardHeader className=\"pb-3\">\n                <CardTitle className=\"text-base\">Cell Alignment</CardTitle>\n                <CardDescription className=\"text-sm\">\n                  Set text alignment for cell content\n                </CardDescription>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                <AlignmentIconPicker\n                  label=\"Horizontal\"\n                  type=\"horizontal\"\n                  value={getCurrentCellAlignment('horizontal')}\n                  onChange={(value) => handleCellAlignmentChange(value, 'horizontal')}\n                  disabled={isDisabled || (isMultipleSelection && isCellAlignmentMixed('horizontal'))}\n                  isMixed={isMultipleSelection && isCellAlignmentMixed('horizontal')}\n                />\n\n                <AlignmentIconPicker\n                  label=\"Vertical\"\n                  type=\"vertical\"\n                  value={getCurrentCellAlignment('vertical')}\n                  onChange={(value) => handleCellAlignmentChange(value, 'vertical')}\n                  disabled={isDisabled || (isMultipleSelection && isCellAlignmentMixed('vertical'))}\n                  isMixed={isMultipleSelection && isCellAlignmentMixed('vertical')}\n                />\n              </CardContent>\n            </Card>\n\n            {/* Clear Styles */}\n            <Card>\n              <CardHeader className=\"pb-3\">\n                <CardTitle className=\"text-base\">Reset Styles</CardTitle>\n                <CardDescription className=\"text-sm\">\n                  Remove custom styling and formatting\n                </CardDescription>\n              </CardHeader>\n              <CardContent className=\"space-y-3\">\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  className=\"w-full justify-start gap-2 h-9\"\n                  disabled={isDisabled}\n                  onClick={clearCellStyles}\n                >\n                  <Eraser className=\"h-4 w-4\" />\n                  Clear Cell Styles\n                </Button>\n                <Button\n                  variant=\"outline\"\n                  size=\"sm\"\n                  className=\"w-full justify-start gap-2 h-9\"\n                  disabled={isDisabled}\n                  onClick={clearHeaderStyles}\n                >\n                  <Eraser className=\"h-4 w-4\" />\n                  Clear Header Styles\n                </Button>\n              </CardContent>\n            </Card>\n\n            {/* Header Text */}\n            <Card>\n              <CardHeader className=\"pb-3\">\n                <CardTitle className=\"text-base\">Header Text</CardTitle>\n                <CardDescription className=\"text-sm\">\n                  Header text display options\n                </CardDescription>\n              </CardHeader>\n              <CardContent className=\"space-y-3\">\n                <ThreeStateCheckbox\n                  label=\"Wrap Header Text\"\n                  property=\"wrapHeaderText\"\n                  mixedValue={getMixedValue('wrapHeaderText')}\n                  onChange={(value) => updateBulkProperty('wrapHeaderText', value)}\n                  disabled={isDisabled || (isMultipleSelection && getMixedValue('wrapHeaderText').isMixed)}\n                  description=\"Wrap long text in column headers\"\n                />\n\n                <ThreeStateCheckbox\n                  label=\"Auto Header Height\"\n                  property=\"autoHeaderHeight\"\n                  mixedValue={getMixedValue('autoHeaderHeight')}\n                  onChange={(value) => updateBulkProperty('autoHeaderHeight', value)}\n                  disabled={isDisabled || (isMultipleSelection && getMixedValue('autoHeaderHeight').isMixed)}\n                  description=\"Automatically adjust header height\"\n                />\n              </CardContent>\n            </Card>\n          </div>\n        </div>\n\n        {/* Style Editors */}\n        <StyleEditor\n          open={showCellStyleEditor}\n          onOpenChange={setShowCellStyleEditor}\n          title=\"Cell Style Editor\"\n          initialStyle={currentCellStyle.isMixed ? {} : (getCellStyleObject() as React.CSSProperties || {})}\n          onSave={handleCellStyleSave}\n          isHeaderStyle={false}\n        />\n\n        <StyleEditor\n          open={showHeaderStyleEditor}\n          onOpenChange={setShowHeaderStyleEditor}\n          title=\"Header Style Editor\"\n          initialStyle={currentHeaderStyle.isMixed ? {} : (getHeaderStyleObject() as React.CSSProperties || {})}\n          onSave={handleHeaderStyleSave}\n          isHeaderStyle={true}\n        />\n      </div>\n    </ScrollArea>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/tabs/ValueFormattersTab.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/dialogs/columnSettings/utils/feedback.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/hooks/useColumnOperations.ts","messages":[{"ruleId":"unused-imports/no-unused-imports","severity":2,"message":"'STATE_RESTORATION_DELAY_MS' is defined but never used.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":36,"fix":{"range":[353,381],"text":""}},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a missing dependency: 'gridApiRef'. Either include it or remove the dependency array.","line":64,"column":5,"nodeType":"ArrayExpression","endLine":64,"endColumn":20,"suggestions":[{"desc":"Update the dependencies array to be: [activeProfile, gridApiRef]","fix":{"range":[2589,2604],"text":"[activeProfile, gridApiRef]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'gridApiRef'. Either include it or remove the dependency array.","line":120,"column":6,"nodeType":"ArrayExpression","endLine":120,"endColumn":72,"suggestions":[{"desc":"Update the dependencies array to be: [gridApiRef, setCurrentColumnDefs, activeProfile, applyColumnChangesDebounced]","fix":{"range":[4423,4489],"text":"[gridApiRef, setCurrentColumnDefs, activeProfile, applyColumnChangesDebounced]"}}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { useCallback, useRef, useMemo } from 'react';\nimport { ColDef, GridApi } from 'ag-grid-community';\nimport { useActiveProfile } from '@/components/datatable/stores/profile.store';\nimport { profileOptimizer } from '@/components/datatable/lib/profileOptimizer';\nimport { debounce } from '@/lib/utils';\nimport { ColumnDef } from '../types';\nimport { STATE_RESTORATION_DELAY_MS, COLUMN_UPDATE_DEBOUNCE_MS } from '../utils/constants';\n\n/**\n * Custom hook for handling column operations and updates\n */\nexport function useColumnOperations(\n  gridApiRef: React.MutableRefObject<GridApi | null>,\n  setCurrentColumnDefs: (columns: ColumnDef[]) => void\n) {\n  const activeProfile = useActiveProfile();\n  const columnDefsWithStylesRef = useRef<ColumnDef[]>([]);\n  \n  // Debounced column update to prevent rapid re-renders\n  const applyColumnChangesDebounced = useMemo(\n    () => debounce((columns: ColDef[]) => {\n      if (gridApiRef.current && activeProfile) {\n        console.log('[useColumnOperations] Applying column definitions to grid');\n        \n        // Simply update the column definitions\n        gridApiRef.current.setGridOption('columnDefs', columns);\n        \n        // Apply the column state from the active profile\n        if (activeProfile.gridState.columnState && activeProfile.gridState.columnState.length > 0) {\n          console.log('[useColumnOperations] Applying column state from active profile:', {\n            profileName: activeProfile.name,\n            columnStateCount: activeProfile.gridState.columnState.length\n          });\n          \n          gridApiRef.current.applyColumnState({\n            state: activeProfile.gridState.columnState,\n            applyOrder: true\n          });\n        }\n        \n        // Apply sort model from profile\n        if (activeProfile.gridState.sortModel && activeProfile.gridState.sortModel.length > 0) {\n          const sortState = activeProfile.gridState.sortModel.map(sort => ({\n            colId: sort.colId,\n            sort: sort.sort,\n            sortIndex: sort.sortIndex\n          }));\n          gridApiRef.current.applyColumnState({ state: sortState });\n        }\n        \n        // Apply filter model from profile\n        if (activeProfile.gridState.filterModel) {\n          gridApiRef.current.setFilterModel(activeProfile.gridState.filterModel);\n        }\n        \n        // Refresh the grid to show the changes\n        gridApiRef.current.refreshHeader();\n        gridApiRef.current.refreshCells({ \n          force: true,\n          suppressFlash: true \n        });\n      }\n    }, COLUMN_UPDATE_DEBOUNCE_MS),\n    [activeProfile]\n  );\n  \n  const handleApplyColumnChanges = useCallback((updatedColumns: ColDef[]) => {\n    console.log('[useColumnOperations] handleApplyColumnChanges:', {\n      updatedColumnsCount: updatedColumns.length,\n      hasGridApi: !!gridApiRef.current,\n      hasCustomizations: updatedColumns.some(col => \n        col.cellStyle || col.valueFormatter || col.cellClass\n      ),\n      firstColumn: updatedColumns[0]?.field\n    });\n    \n    // Store the columns with styles for later retrieval\n    columnDefsWithStylesRef.current = updatedColumns as ColumnDef[];\n    \n    // Update the currentColumnDefs state\n    setCurrentColumnDefs(updatedColumns as ColumnDef[]);\n    \n    // Apply the changes to the grid\n    if (gridApiRef.current) {\n      // Since maintainColumnOrder is true, this should preserve column state\n      applyColumnChangesDebounced(updatedColumns);\n    }\n    \n    // Log what was updated for debugging\n    const updatedFields = updatedColumns.filter(col => \n      col.cellStyle || col.valueFormatter || col.cellClass\n    ).map(col => col.field);\n    \n    if (updatedFields.length > 0) {\n      console.log('[useColumnOperations] Column customizations applied:', {\n        updatedFields,\n        totalColumns: updatedColumns.length\n      });\n    }\n    \n    // Update React state\n    setCurrentColumnDefs(updatedColumns.map((col) => {\n      if (col.field && col.headerName) {\n        return col as ColumnDef;\n      }\n      \n      return {\n        ...col,\n        field: col.field || '',\n        headerName: col.headerName || col.field || ''\n      };\n    }));\n    \n    // Clear optimizer cache for active profile since columns changed\n    if (activeProfile) {\n      profileOptimizer.clearCache(activeProfile.id);\n    }\n    \n    // Column changes from dialog are only saved when Save Profile button is clicked\n  }, [activeProfile, setCurrentColumnDefs, applyColumnChangesDebounced]);\n  \n  // Get column definitions with styles\n  const getColumnDefsWithStyles = useCallback(() => {\n    return columnDefsWithStylesRef.current;\n  }, []);\n  \n  return {\n    handleApplyColumnChanges,\n    getColumnDefsWithStyles,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/hooks/useColumnProcessor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[860,863],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[860,863],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1098,1101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1098,1101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useMemo } from 'react';\nimport { createCellStyleFunction, hasConditionalStyling } from '../utils/styleUtils';\nimport { ColumnDef } from '../types';\n\n/**\n * Custom hook that processes columns to ensure cellStyle functions are created\n * for columns with conditional formatting in their valueFormatters.\n * \n * This preserves the CRITICAL functionality from ensureCellStyleForColumns\n * that merges base styles with conditional styles.\n */\nexport function useColumnProcessor(columns: ColumnDef[]): ColumnDef[] {\n  return useMemo(() => {\n    let hasChanges = false;\n    \n    const processed = columns.map(col => {\n      // Check if valueFormatter has conditional styling that needs cellStyle\n      if (!col.valueFormatter || typeof col.valueFormatter !== 'function') {\n        return col;\n      }\n      \n      const formatString = (col.valueFormatter as any).__formatString;\n      \n      if (!formatString || !hasConditionalStyling(formatString)) {\n        return col;\n      }\n      \n      // Check if cellStyle needs to be created or updated\n      const existingCellStyle = col.cellStyle as any;\n      const needsCellStyle = !col.cellStyle || \n                            (typeof col.cellStyle === 'function' && \n                             existingCellStyle.__formatString !== formatString);\n      \n      if (!needsCellStyle) {\n        return col;\n      }\n      \n      hasChanges = true;\n      \n      console.log('[useColumnProcessor] Creating cellStyle for conditional formatting:', {\n        field: col.field,\n        formatString,\n        hasExistingCellStyle: !!col.cellStyle\n      });\n      \n      // Extract base style if it exists\n      let baseStyle: React.CSSProperties = {};\n      if (col.cellStyle) {\n        if (typeof col.cellStyle === 'object') {\n          baseStyle = col.cellStyle as React.CSSProperties;\n        } else if (typeof col.cellStyle === 'function' && existingCellStyle.__baseStyle) {\n          baseStyle = existingCellStyle.__baseStyle;\n        }\n      }\n      \n      // Create cellStyle function with proper base style merging\n      const cellStyleFn = createCellStyleFunction(formatString, baseStyle);\n      \n      // Attach metadata for future serialization\n      Object.defineProperty(cellStyleFn, '__formatString', { \n        value: formatString, \n        writable: false,\n        enumerable: false,\n        configurable: true\n      });\n      Object.defineProperty(cellStyleFn, '__baseStyle', { \n        value: baseStyle, \n        writable: false,\n        enumerable: false,\n        configurable: true\n      });\n      \n      return { ...col, cellStyle: cellStyleFn };\n    });\n    \n    // Only return new array if changes were made\n    return hasChanges ? processed : columns;\n  }, [columns]);\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/hooks/useDataTableContext.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/hooks/useGridCallbacks.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[674,677],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[674,677],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[680,683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[680,683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'gridApiRef'. Either include it or remove the dependency array.","line":125,"column":6,"nodeType":"ArrayExpression","endLine":125,"endColumn":50,"suggestions":[{"desc":"Update the dependencies array to be: [gridApiRef, setGridApi, activeProfile, setSelectedFont]","fix":{"range":[4406,4450],"text":"[gridApiRef, setGridApi, activeProfile, setSelectedFont]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":178,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6086,6089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6086,6089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":189,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6482,6485],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6482,6485],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useMemo } from 'react';\nimport { GridApi, GridReadyEvent } from 'ag-grid-community';\nimport { useActiveProfile } from '@/components/datatable/stores/profile.store';\nimport { useDataTableContext } from './useDataTableContext';\n\n/**\n * Custom hook for memoized grid callbacks to prevent unnecessary re-renders\n */\nexport function useGridCallbacks(\n  gridApiRef: React.MutableRefObject<GridApi | null>,\n  setSelectedFont: (font: string) => void\n) {\n  const activeProfile = useActiveProfile();\n  const { setGridApi } = useDataTableContext();\n  \n  // Context menu items - now includes Format Column option\n  const getContextMenuItems = useCallback((params: any): any => {\n    const defaultItems = [\n      \"autoSizeAll\",\n      \"resetColumns\",\n      \"separator\",\n      \"copy\",\n      \"copyWithHeaders\",\n      \"paste\",\n      \"separator\",\n      \"export\",\n    ];\n    \n    // Only add Format Column for column headers, not cell context menus\n    if (params.column) {\n      return [\n        {\n          name: 'Format Column',\n          action: () => {\n            // Dispatch custom event with column info and click position\n            const event = new CustomEvent('format-column', {\n              detail: {\n                colId: params.column.getColId(),\n                colDef: params.column.getColDef(),\n                x: params.event?.clientX || 0,\n                y: params.event?.clientY || 0\n              }\n            });\n            window.dispatchEvent(event);\n          },\n          icon: '<span class=\"ag-icon ag-icon-columns\" style=\"font-size: 14px;\">🎨</span>'\n        },\n        \"separator\",\n        ...defaultItems\n      ];\n    }\n    \n    return defaultItems;\n  }, []);\n  \n  // Grid ready handler\n  const onGridReady = useCallback(async (params: GridReadyEvent) => {\n    gridApiRef.current = params.api;\n    \n    // Update the state version of gridApi for components that need it\n    if (setGridApi) {\n      setGridApi(params.api);\n    }\n    \n    console.log('[useGridCallbacks] onGridReady:', {\n      hasActiveProfile: !!activeProfile,\n      activeProfileId: activeProfile?.id,\n      activeProfileName: activeProfile?.name,\n      hasGridState: !!activeProfile?.gridState\n    });\n    \n    // Load active profile on grid ready - SIMPLIFIED APPROACH\n    if (activeProfile && activeProfile.gridState) {\n      console.log('[useGridCallbacks] Applying active profile on grid ready:', {\n        profileId: activeProfile.id,\n        profileName: activeProfile.name,\n        hasColumnState: !!activeProfile.gridState.columnState,\n        columnStateLength: activeProfile.gridState.columnState?.length\n      });\n      \n      try {\n        // Apply states in a deterministic order with proper timing\n        \n        // 1. Apply column state (visibility, width, position, sort)\n        if (activeProfile.gridState.columnState && activeProfile.gridState.columnState.length > 0) {\n          console.log('[useGridCallbacks] Applying column state');\n          params.api.applyColumnState({\n            state: activeProfile.gridState.columnState,\n            applyOrder: true\n          });\n        }\n        \n        // 2. Apply filter model\n        if (activeProfile.gridState.filterModel) {\n          console.log('[useGridCallbacks] Applying filter model');\n          params.api.setFilterModel(activeProfile.gridState.filterModel);\n        }\n        \n        // 3. Apply grid options\n        if (activeProfile.gridState.gridOptions) {\n          console.log('[useGridCallbacks] Applying grid options');\n          const options = activeProfile.gridState.gridOptions;\n          if (options.rowHeight) {\n            params.api.resetRowHeights();\n            params.api.setGridOption('rowHeight', options.rowHeight);\n          }\n          if (options.headerHeight) {\n            params.api.setGridOption('headerHeight', options.headerHeight);\n          }\n        }\n        \n        // 4. Apply font\n        if (activeProfile.gridState.font) {\n          console.log('[useGridCallbacks] Applying font:', activeProfile.gridState.font);\n          setSelectedFont(activeProfile.gridState.font);\n        }\n        \n        console.log('[useGridCallbacks] Profile applied successfully');\n      } catch (error) {\n        console.error('[useGridCallbacks] Error applying profile:', error);\n      }\n    } else {\n      console.log('[useGridCallbacks] No active profile or gridState to apply');\n    }\n  }, [activeProfile, setSelectedFont, setGridApi]);\n  \n  // Column event handlers - no auto-save, only saved when Save Profile button is clicked\n  const onColumnMoved = useCallback(() => {\n    // State changes are only saved when Save Profile button is clicked\n  }, []);\n  \n  const onColumnResized = useCallback(() => {\n    // State changes are only saved when Save Profile button is clicked\n  }, []);\n  \n  const onColumnVisible = useCallback(() => {\n    // State changes are only saved when Save Profile button is clicked\n  }, []);\n  \n  const onToolPanelVisibleChanged = useCallback(() => {\n    // State changes are only saved when Save Profile button is clicked\n  }, []);\n  \n  const onSortChanged = useCallback(() => {\n    // State changes are only saved when Save Profile button is clicked\n  }, []);\n  \n  const onFilterChanged = useCallback(() => {\n    // State changes are only saved when Save Profile button is clicked\n  }, []);\n  \n  // Excel export styles\n  const excelStyles = useMemo(() => [\n    {\n      id: 'header',\n      font: { bold: true },\n      alignment: { horizontal: 'Center' as const, vertical: 'Center' as const }\n    },\n    {\n      id: 'ag-numeric-cell',\n      alignment: { horizontal: 'Right' as const }\n    },\n    {\n      id: 'ag-currency-cell',\n      numberFormat: { format: '$#,##0.00' },\n      alignment: { horizontal: 'Right' as const }\n    },\n    {\n      id: 'ag-percentage-cell',\n      numberFormat: { format: '0.00%' },\n      alignment: { horizontal: 'Right' as const }\n    }\n  ], []);\n  \n  // Default Excel export params\n  const defaultExcelExportParams = useMemo(() => ({\n    // Apply column formatting to Excel export\n    processCellCallback: (params: any) => {\n      const colDef = params.column.getColDef();\n      // Use valueFormatter for export if available\n      if (colDef.valueFormatter) {\n        return typeof colDef.valueFormatter === 'function'\n          ? colDef.valueFormatter(params)\n          : params.value;\n      }\n      return params.value;\n    },\n    // Include column headers with formatting\n    processHeaderCallback: (params: any) => {\n      return params.column.getColDef().headerName || params.column.getColId();\n    }\n  }), []);\n  \n  return {\n    // Event handlers\n    getContextMenuItems,\n    onGridReady,\n    onColumnMoved,\n    onColumnResized,\n    onColumnVisible,\n    onToolPanelVisibleChanged,\n    onSortChanged,\n    onFilterChanged,\n    \n    // Export configuration\n    excelStyles,\n    defaultExcelExportParams,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/hooks/useGridState.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1472,1475],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1472,1475],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback } from 'react';\nimport { useProfileStore, useActiveProfile } from '@/components/datatable/stores/profile.store';\nimport { ColumnDef } from '../types';\n\n/**\n * Custom hook for managing DataTable grid state\n */\nexport function useGridState(initialColumnDefs: ColumnDef[]) {\n  const activeProfile = useActiveProfile();\n  const { getColumnDefs } = useProfileStore();\n  \n  // Initialize font from active profile\n  const [selectedFont, setSelectedFont] = useState(() => {\n    return activeProfile?.gridState?.font || 'monospace';\n  });\n  \n  // Dialog visibility\n  const [showColumnDialog, setShowColumnDialog] = useState(false);\n  \n  // Initialize column definitions from profile or use defaults\n  const [currentColumnDefs, setCurrentColumnDefs] = useState<ColumnDef[]>(() => {\n    // Try to get column definitions from profile (will use lightweight format if available)\n    const savedColumnDefs = getColumnDefs();\n    \n    if (savedColumnDefs && savedColumnDefs.length > 0) {\n      console.log('[useGridState] Initializing with saved columnDefs from profile:', {\n        profileName: activeProfile?.name,\n        profileId: activeProfile?.id,\n        columnCount: savedColumnDefs.length,\n        hasLightweightFormat: !!(activeProfile?.gridState?.columnCustomizations),\n        hasBaseColumnDefs: !!(activeProfile?.gridState?.baseColumnDefs),\n        sampleColumn: savedColumnDefs[0],\n        columnsWithFormatters: savedColumnDefs.filter((col: any) => col.valueFormatter).length\n      });\n      \n      return savedColumnDefs as ColumnDef[];\n    }\n    \n    console.log('[useGridState] Initializing with default columnDefs');\n    return initialColumnDefs;\n  });\n  \n  // Font change handler\n  const handleFontChange = useCallback((font: string) => {\n    setSelectedFont(font);\n    // Font changes are only saved when Save Profile button is clicked\n  }, []);\n  \n  // Update column definitions\n  const updateColumnDefs = useCallback((columns: ColumnDef[]) => {\n    setCurrentColumnDefs(columns);\n  }, []);\n  \n  return {\n    // State\n    currentColumnDefs,\n    selectedFont,\n    showColumnDialog,\n    \n    // Actions\n    setCurrentColumnDefs: updateColumnDefs,\n    setSelectedFont: handleFontChange,\n    setShowColumnDialog,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/hooks/useProfileSync.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/lib/dataGenerator.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/lib/performanceMonitor.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":65,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1780,1783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1780,1783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Performance monitoring utility\nexport interface PerformanceMetrics {\n  appStartTime: number;\n  gridInitTime?: number;\n  profileLoadTime?: number;\n  dataGenerationTime?: number;\n  firstRenderTime?: number;\n  fullyLoadedTime?: number;\n  [key: string]: number | undefined;\n}\n\nclass PerformanceMonitor {\n  private metrics: PerformanceMetrics;\n  private marks: Map<string, number> = new Map();\n\n  constructor() {\n    this.metrics = {\n      appStartTime: performance.now()\n    };\n  }\n\n  mark(name: string) {\n    const time = performance.now();\n    this.marks.set(name, time);\n    // console.log(`[Performance] ${name}: ${time.toFixed(2)}ms`);\n  }\n\n  measure(name: string, startMark: string, endMark?: string) {\n    const startTime = this.marks.get(startMark) || 0;\n    const endTime = endMark ? (this.marks.get(endMark) || performance.now()) : performance.now();\n    const duration = endTime - startTime;\n    \n    this.metrics[name] = duration;\n    // console.log(`[Performance] ${name}: ${duration.toFixed(2)}ms`);\n    \n    return duration;\n  }\n\n  measureFromStart(name: string) {\n    const duration = performance.now() - this.metrics.appStartTime;\n    this.metrics[name] = duration;\n    // console.log(`[Performance] ${name} from start: ${duration.toFixed(2)}ms`);\n    return duration;\n  }\n\n  getMetrics(): PerformanceMetrics {\n    return { ...this.metrics };\n  }\n\n  logSummary() {\n    // console.group('📊 Performance Summary');\n    // Object.entries(this.metrics).forEach(([key, value]) => {\n    //   if (value !== undefined) {\n    //     console.log(`${key}: ${value.toFixed(2)}ms`);\n    //   }\n    // });\n    // console.groupEnd();\n  }\n}\n\nexport const perfMonitor = new PerformanceMonitor();\n\n// Export to window for debugging\nif (typeof window !== 'undefined') {\n  (window as any).perfMonitor = perfMonitor;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/lib/performanceTest.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":124,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3680,3683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3680,3683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":127,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3755,3758],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3755,3758],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":133,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":133,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3907,3910],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3907,3910],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Performance testing utilities\nimport { perfMonitor } from './performanceMonitor';\n\nexport interface PerformanceTestResult {\n  testName: string;\n  metrics: {\n    [key: string]: number;\n  };\n  timestamp: number;\n  userAgent: string;\n}\n\nclass PerformanceTester {\n  private results: PerformanceTestResult[] = [];\n\n  async runLoadTest(): Promise<PerformanceTestResult> {\n    const testName = 'Page Load Performance';\n    const metrics = perfMonitor.getMetrics();\n    \n    // Calculate derived metrics\n    const derivedMetrics = {\n      ...metrics,\n      totalLoadTime: metrics.fullyLoadedTime || 0,\n      gridLoadTime: (metrics.gridInitTime || 0) - (metrics.appStartTime || 0),\n      dataGenTime: metrics.dataGenerationTime || 0,\n      profileLoadOverhead: metrics.profileLoadTime || 0,\n      perceivedLoadTime: metrics.firstRenderTime || 0,\n    };\n\n    const result: PerformanceTestResult = {\n      testName,\n      metrics: derivedMetrics,\n      timestamp: Date.now(),\n      userAgent: navigator.userAgent,\n    };\n\n    this.results.push(result);\n    return result;\n  }\n\n  async runProfileSwitchTest(profileId: string): Promise<PerformanceTestResult> {\n    const startTime = performance.now();\n    \n    // This would need to be integrated with the actual profile switching logic\n    // For now, we'll just measure the time it takes to switch profiles\n    \n    const endTime = performance.now();\n    const switchTime = endTime - startTime;\n\n    const result: PerformanceTestResult = {\n      testName: 'Profile Switch Performance',\n      metrics: {\n        profileSwitchTime: switchTime,\n        profileId: profileId.length, // Just for reference\n      },\n      timestamp: Date.now(),\n      userAgent: navigator.userAgent,\n    };\n\n    this.results.push(result);\n    return result;\n  }\n\n  getResults(): PerformanceTestResult[] {\n    return [...this.results];\n  }\n\n  generateReport(): string {\n    const report = ['# Performance Test Report', ''];\n    \n    this.results.forEach((result, index) => {\n      report.push(`## Test ${index + 1}: ${result.testName}`);\n      report.push(`Timestamp: ${new Date(result.timestamp).toISOString()}`);\n      report.push('');\n      report.push('### Metrics:');\n      \n      Object.entries(result.metrics).forEach(([key, value]) => {\n        if (typeof value === 'number') {\n          report.push(`- ${key}: ${value.toFixed(2)}ms`);\n        }\n      });\n      \n      report.push('');\n    });\n\n    // Summary statistics\n    if (this.results.length > 0) {\n      report.push('## Summary');\n      report.push('');\n      \n      const loadTests = this.results.filter(r => r.testName === 'Page Load Performance');\n      if (loadTests.length > 0) {\n        const avgTotalLoad = loadTests.reduce((sum, test) => \n          sum + (test.metrics.totalLoadTime || 0), 0) / loadTests.length;\n        const avgPerceivedLoad = loadTests.reduce((sum, test) => \n          sum + (test.metrics.perceivedLoadTime || 0), 0) / loadTests.length;\n        \n        report.push(`- Average Total Load Time: ${avgTotalLoad.toFixed(2)}ms`);\n        report.push(`- Average Perceived Load Time: ${avgPerceivedLoad.toFixed(2)}ms`);\n      }\n    }\n\n    return report.join('\\n');\n  }\n\n  logReport(): void {\n    console.group('📊 Performance Test Report');\n    \n    this.results.forEach((result, index) => {\n      console.group(`Test ${index + 1}: ${result.testName}`);\n      console.table(result.metrics);\n      console.log('Timestamp:', new Date(result.timestamp).toISOString());\n      console.groupEnd();\n    });\n    \n    console.groupEnd();\n  }\n}\n\nexport const perfTester = new PerformanceTester();\n\n// Export to window for easy access\nif (typeof window !== 'undefined') {\n  (window as any).perfTester = perfTester;\n  \n  // Add convenience methods\n  (window as any).runPerfTest = async () => {\n    const result = await perfTester.runLoadTest();\n    perfTester.logReport();\n    return result;\n  };\n  \n  (window as any).getPerfReport = () => {\n    return perfTester.generateReport();\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/lib/profileOptimizer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[856,859],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[856,859],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1068,1071],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1068,1071],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":90,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3090,3093],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3090,3093],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":91,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3135,3138],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3135,3138],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3182,3185],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3182,3185],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":95,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3314,3317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3314,3317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":99,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3520,3523],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3520,3523],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":113,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":113,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4077,4080],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4077,4080],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":255,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9004,9007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9004,9007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":285,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":285,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10407,10410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10407,10410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":341,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":341,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12955,12958],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12955,12958],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":342,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":342,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13050,13053],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13050,13053],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":348,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":348,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13318,13321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13318,13321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":507,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":507,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18510,18513],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18510,18513],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":549,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":549,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19712,19715],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19712,19715],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":15,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ColDef, ColumnState, SortModelItem, GridApi } from 'ag-grid-community';\nimport { GridProfile } from '@/components/datatable/stores/profile.store';\nimport { deserializeColumnCustomizations } from '@/components/datatable/stores/columnSerializer';\nimport { createExcelFormatter } from '@/components/datatable/utils/formatters';\n\ninterface ProfileCache {\n  processedColumnDefs: ColDef[];\n  columnStateHash: string;\n  filterModelHash: string;\n  sortModelHash: string;\n  timestamp: number;\n}\n\ninterface ProfileDiff {\n  columnDefsChanged: boolean;\n  columnStateChanged: boolean;\n  filterModelChanged: boolean;\n  sortModelChanged: boolean;\n  gridOptionsChanged: boolean;\n  changes: {\n    addedColumns: string[];\n    removedColumns: string[];\n    modifiedColumns: string[];\n    columnStateChanges: Partial<ColumnState>[];\n    filterChanges: Record<string, any>;\n    sortChanges: SortModelItem[];\n  };\n}\n\nclass ProfileOptimizer {\n  private cache = new Map<string, ProfileCache>();\n  private currentProfileId: string | null = null;\n  private pendingUpdates: Map<string, any> = new Map();\n  private updateFrameId: number | null = null;\n  \n  // Pre-process profiles in background\n  async preprocessProfile(profile: GridProfile) {\n    if (this.cache.has(profile.id)) {\n      const cached = this.cache.get(profile.id)!;\n      // Cache is valid for 5 minutes\n      if (Date.now() - cached.timestamp < 5 * 60 * 1000) {\n        return;\n      }\n    }\n    \n    // Use requestIdleCallback for background processing\n    if ('requestIdleCallback' in window) {\n      requestIdleCallback(() => this.processProfile(profile), { timeout: 2000 });\n    } else {\n      setTimeout(() => this.processProfile(profile), 100);\n    }\n  }\n  \n  private processProfile(profile: GridProfile) {\n    // perfMonitor.mark('profile-process-start');\n    \n    let processedColumnDefs: ColDef[] = [];\n    \n    // Process column definitions\n    if (profile.gridState.columnCustomizations && profile.gridState.baseColumnDefs && profile.gridState.baseColumnDefs.length > 0) {\n      processedColumnDefs = deserializeColumnCustomizations(\n        profile.gridState.columnCustomizations,\n        profile.gridState.baseColumnDefs\n      );\n    } else if (profile.gridState.columnDefs) {\n      processedColumnDefs = this.processLegacyColumnDefs(profile.gridState.columnDefs);\n    }\n    \n    // Create hashes for quick comparison\n    const columnStateHash = this.hashObject(profile.gridState.columnState || []);\n    const filterModelHash = this.hashObject(profile.gridState.filterModel || {});\n    const sortModelHash = this.hashObject(profile.gridState.sortModel || []);\n    \n    this.cache.set(profile.id, {\n      processedColumnDefs,\n      columnStateHash,\n      filterModelHash,\n      sortModelHash,\n      timestamp: Date.now()\n    });\n    \n          // perfMonitor.measure('profileProcessTime', 'profile-process-start');\n  }\n  \n  private processLegacyColumnDefs(columnDefs: ColDef[]): ColDef[] {\n    return columnDefs.map(col => {\n      const processed = { ...col };\n      \n      // Clean invalid properties\n      delete (processed as any).valueFormat;\n      delete (processed as any)._hasFormatter;\n      delete (processed as any).excelFormat;\n      \n      // Remove hide property - visibility should be controlled by column state\n      delete (processed as any).hide;\n      \n      // Convert headerStyle objects back to functions\n      if (processed.headerStyle && typeof processed.headerStyle === 'object') {\n        const styleConfig = processed.headerStyle as any;\n        \n        if (styleConfig._isHeaderStyleConfig) {\n          processed.headerStyle = ((params: { floatingFilter?: boolean }) => {\n            if (params?.floatingFilter) {\n              return styleConfig.floating || null;\n            }\n            return styleConfig.regular || null;\n          }) as ColDef['headerStyle'];\n        }\n      }\n      \n      // Recreate valueFormatter from saved config\n      if (processed.valueFormatter && typeof processed.valueFormatter === 'object') {\n        const formatterConfig = processed.valueFormatter as any;\n        \n        if (formatterConfig._isFormatterConfig && formatterConfig.type === 'excel' && formatterConfig.formatString) {\n          // Recreate the formatter function\n          const formatter = createExcelFormatter(formatterConfig.formatString);\n          processed.valueFormatter = formatter;\n          // Value formatter will be used for export automatically\n        } else {\n          // Invalid formatter config, remove it\n          delete processed.valueFormatter;\n          // No export formatter needed\n        }\n      }\n      \n      return processed;\n    });\n  }\n  \n  // Calculate diff between current and target profile\n  calculateDiff(currentProfile: GridProfile | null, targetProfile: GridProfile): ProfileDiff {\n    const diff: ProfileDiff = {\n      columnDefsChanged: false,\n      columnStateChanged: false,\n      filterModelChanged: false,\n      sortModelChanged: false,\n      gridOptionsChanged: false,\n      changes: {\n        addedColumns: [],\n        removedColumns: [],\n        modifiedColumns: [],\n        columnStateChanges: [],\n        filterChanges: {},\n        sortChanges: []\n      }\n    };\n    \n    if (!currentProfile) {\n      // Everything is new\n      diff.columnDefsChanged = true;\n      diff.columnStateChanged = true;\n      diff.filterModelChanged = !!targetProfile.gridState.filterModel;\n      diff.sortModelChanged = !!targetProfile.gridState.sortModel?.length;\n      diff.gridOptionsChanged = !!targetProfile.gridState.gridOptions;\n      return diff;\n    }\n    \n    // Compare column definitions\n    const currentCache = this.cache.get(currentProfile.id);\n    const targetCache = this.cache.get(targetProfile.id);\n    \n    if (!currentCache || !targetCache || \n        currentCache.processedColumnDefs.length !== targetCache.processedColumnDefs.length) {\n      diff.columnDefsChanged = true;\n    } else {\n      // Deep comparison of column definitions\n      for (let i = 0; i < currentCache.processedColumnDefs.length; i++) {\n        const current = currentCache.processedColumnDefs[i];\n        const target = targetCache.processedColumnDefs[i];\n        \n        if (JSON.stringify(current) !== JSON.stringify(target)) {\n          diff.columnDefsChanged = true;\n          diff.changes.modifiedColumns.push(current.field || '');\n        }\n      }\n    }\n    \n    // Compare states using hashes\n    diff.columnStateChanged = currentCache?.columnStateHash !== targetCache?.columnStateHash;\n    diff.filterModelChanged = currentCache?.filterModelHash !== targetCache?.filterModelHash;\n    diff.sortModelChanged = currentCache?.sortModelHash !== targetCache?.sortModelHash;\n    \n    // Compare grid options\n    diff.gridOptionsChanged = JSON.stringify(currentProfile.gridState.gridOptions) !== \n                             JSON.stringify(targetProfile.gridState.gridOptions);\n    \n    return diff;\n  }\n  \n  // Apply profile with optimizations\n  async applyProfile(\n    gridApi: GridApi,\n    profile: GridProfile,\n    currentProfile: GridProfile | null,\n    options: {\n      showTransition?: boolean;\n      onProgress?: (progress: number) => void;\n    } = {}\n  ) {\n    const startTime = performance.now();\n    // perfMonitor.mark('profile-switch-start');\n    \n    // Ensure profile is preprocessed\n    if (!this.cache.has(profile.id)) {\n      await this.processProfile(profile);\n    }\n    \n    const cached = this.cache.get(profile.id);\n    if (!cached) {\n      console.error('[ProfileOptimizer] Failed to cache profile:', profile.id);\n      return;\n    }\n    \n    // Calculate diff\n    const diff = this.calculateDiff(currentProfile, profile);\n    \n    // Show transition if needed\n    if (options.showTransition) {\n      this.showTransitionEffect(gridApi);\n    }\n    \n    // Optimistic update - immediately update visual indicators\n    this.currentProfileId = profile.id;\n    \n    // Cancel any pending updates from previous profile switches\n    if (this.updateFrameId !== null) {\n      cancelAnimationFrame(this.updateFrameId);\n      this.updateFrameId = null;\n    }\n    this.pendingUpdates.clear();\n    \n    // Apply updates synchronously for consistency\n    let progress = 0;\n    const totalSteps = Object.keys(diff).filter(key => diff[key as keyof ProfileDiff]).length;\n    \n    try {\n      // Step 1: Clear existing state to prevent bleeding\n      if (diff.columnDefsChanged || diff.columnStateChanged) {\n        // Force a clean state by resetting filters and sorts\n        gridApi.setFilterModel({});\n        // Clear sort using applyColumnState with empty sort state\n        const allColumns = gridApi.getColumns();\n        if (allColumns) {\n          const clearSortState = allColumns.map(col => ({\n            colId: col.getColId(),\n            sort: null,\n            sortIndex: null\n          }));\n          gridApi.applyColumnState({ state: clearSortState });\n        }\n      }\n      \n      // Collect all updates to apply in a single transaction\n      const gridUpdates: any = {};\n      let needsHeaderRefresh = false;\n      let needsFilterRefresh = false;\n      \n      // Step 1: Prepare column definitions if changed OR if this is the initial load\n      const isInitialLoad = currentProfile === null;\n      if ((diff.columnDefsChanged || isInitialLoad) && cached.processedColumnDefs.length > 0) {\n        // IMPORTANT: When updating column definitions, AG-Grid resets column state\n        // So we need to capture the target column state and ensure it's applied after\n        // the column definitions are updated\n        \n        // Get current defaultColDef to ensure it's preserved\n        const defaultColDef = gridApi.getGridOption('defaultColDef') || {\n          minWidth: 100,\n          filter: true,\n          floatingFilter: true,\n          enableValue: true,\n          enableRowGroup: true,\n          enablePivot: true,\n          resizable: true,\n          sortable: true,\n          useValueFormatterForExport: true,\n        };\n        \n        // Remove any hide properties from column definitions\n        // Column visibility should only be controlled by column state\n        // Also ensure we start with clean column definitions to prevent style bleeding\n        const cleanedColumnDefs = cached.processedColumnDefs.map(col => {\n          // Create a fresh copy to avoid any reference issues\n          const cleaned = { ...col };\n          delete (cleaned as any).hide;\n          \n          // Ensure styles are properly set (not carrying over from previous profile)\n          if (cleaned.cellStyle && typeof cleaned.cellStyle === 'function') {\n            // Re-create the function to ensure it's not a stale reference\n            const originalFunc = cleaned.cellStyle;\n            cleaned.cellStyle = originalFunc;\n          }\n          \n          if (cleaned.headerStyle && typeof cleaned.headerStyle === 'function') {\n            // Re-create the function to ensure it's not a stale reference\n            const originalFunc = cleaned.headerStyle;\n            cleaned.headerStyle = originalFunc;\n          }\n          \n          return cleaned;\n        });\n        \n        gridUpdates.columnDefs = cleanedColumnDefs;\n        gridUpdates.defaultColDef = defaultColDef;\n        \n        // Check if we need header refresh\n        needsHeaderRefresh = cached.processedColumnDefs.some(col => \n          col.floatingFilter !== false || col.headerStyle\n        );\n        \n        progress++;\n        options.onProgress?.(progress / totalSteps);\n      }\n      \n      // Apply all grid updates in one call\n      if (Object.keys(gridUpdates).length > 0) {\n        console.log('[ProfileOptimizer] Applying grid updates:', {\n          hasColumnDefs: !!gridUpdates.columnDefs,\n          columnDefsCount: gridUpdates.columnDefs?.length,\n          hasDefaultColDef: !!gridUpdates.defaultColDef\n        });\n        gridApi.updateGridOptions(gridUpdates);\n        \n        // IMPORTANT: If we updated column definitions, we need to apply column state immediately\n        // AG-Grid resets column state when columnDefs change, so we can't defer this\n        needsHeaderRefresh = true;\n        \n        // Give AG-Grid a moment to process the column definition changes\n        await new Promise(resolve => setTimeout(resolve, 0));\n      }\n      \n      // Apply column state, sort, and filter immediately (not deferred)\n      // This ensures proper state application after column definition changes\n      \n      // 1. Column state (includes visibility, width, position)\n      // IMPORTANT: Always apply column state if we updated column definitions\n      // because AG-Grid resets state when columnDefs change\n      if ((diff.columnStateChanged || diff.columnDefsChanged || isInitialLoad) && profile.gridState.columnState) {\n        console.log('[ProfileOptimizer] Applying column state:', {\n          stateCount: profile.gridState.columnState.length,\n          hiddenColumns: profile.gridState.columnState.filter((col: any) => col.hide).length,\n          visibleColumns: profile.gridState.columnState.filter((col: any) => !col.hide).length,\n          sample: profile.gridState.columnState.slice(0, 3)\n        });\n        \n        // Log the state we're about to apply\n        console.log('[ProfileOptimizer] Column state to apply:', \n          profile.gridState.columnState.map((s: any) => ({\n            colId: s.colId,\n            hide: s.hide,\n            width: s.width,\n            pinned: s.pinned\n          }))\n        );\n        \n        const result = gridApi.applyColumnState({\n          state: profile.gridState.columnState,\n          applyOrder: true\n        });\n        \n        console.log('[ProfileOptimizer] applyColumnState result:', result);\n        \n        // Verify the state was applied\n        const appliedState = gridApi.getColumnState();\n        const allColumns = gridApi.getColumns();\n        console.log('[ProfileOptimizer] Column state after apply:', {\n          stateCount: appliedState.length,\n          hiddenColumns: appliedState.filter(col => col.hide).length,\n          visibleColumns: appliedState.filter(col => !col.hide).length,\n          appliedSuccessfully: result === true,\n          actualVisibleColumns: allColumns?.filter(c => c.isVisible()).length,\n          actualColumns: allColumns?.map(c => ({\n            colId: c.getColId(),\n            visible: c.isVisible()\n          }))\n        });\n        \n        progress++;\n        options.onProgress?.(progress / totalSteps);\n      }\n      \n      // 2. Sort model (part of column state)\n      if (diff.sortModelChanged && profile.gridState.sortModel?.length > 0) {\n        const sortState = profile.gridState.sortModel.map(sort => ({\n          colId: sort.colId,\n          sort: sort.sort,\n          sortIndex: sort.sortIndex\n        }));\n        gridApi.applyColumnState({ state: sortState });\n        progress++;\n        options.onProgress?.(progress / totalSteps);\n      }\n      \n      // 3. Filter model (apply after column state)\n      if (diff.filterModelChanged) {\n        gridApi.setFilterModel(profile.gridState.filterModel || {});\n        needsFilterRefresh = true;\n        progress++;\n        options.onProgress?.(progress / totalSteps);\n      }\n      \n      // 4. Single refresh at the end if needed\n      if (needsHeaderRefresh || needsFilterRefresh) {\n        requestAnimationFrame(() => {\n          if (needsHeaderRefresh) {\n            gridApi.refreshHeader();\n          }\n          if (needsFilterRefresh) {\n            // In AG-Grid v33, refreshFilters doesn't exist\n            // Instead, we notify that filters have changed\n            gridApi.onFilterChanged();\n          }\n        });\n      }\n      \n      // Apply grid options if changed\n      if (diff.gridOptionsChanged && profile.gridState.gridOptions) {\n        const options = profile.gridState.gridOptions!;\n        if (options.rowHeight) {\n          gridApi.resetRowHeights();\n          gridApi.setGridOption('rowHeight', options.rowHeight);\n        }\n        if (options.headerHeight) {\n          gridApi.setGridOption('headerHeight', options.headerHeight);\n        }\n        progress++;\n        options.onProgress?.(progress / totalSteps);\n      }\n    } catch (error) {\n      console.error('[ProfileOptimizer] Error switching profile:', error);\n      // Re-throw to let caller handle\n      throw error;\n    }\n    \n    // Log performance metrics\n    const endTime = performance.now();\n    const switchTime = endTime - startTime;\n    \n    console.log('[ProfileOptimizer] Profile switch completed:', {\n      profileId: profile.id,\n      profileName: profile.name,\n      switchTime: `${switchTime.toFixed(1)}ms`,\n      operations: {\n        columnDefsChanged: diff.columnDefsChanged,\n        columnStateChanged: diff.columnStateChanged,\n        filterModelChanged: diff.filterModelChanged,\n        sortModelChanged: diff.sortModelChanged,\n        gridOptionsChanged: diff.gridOptionsChanged\n      }\n    });\n    \n    // perfMonitor.measure('profileSwitchTime', 'profile-switch-start');\n  }\n  \n  private batchUpdates(callback: () => void) {\n    // Cancel any pending frame\n    if (this.updateFrameId !== null) {\n      cancelAnimationFrame(this.updateFrameId);\n    }\n    \n    callback();\n    \n    // Process updates in next animation frame\n    this.updateFrameId = requestAnimationFrame(() => {\n      this.processPendingUpdates();\n    });\n  }\n  \n  private scheduleUpdate(key: string, update: () => void, priority: number = 0) {\n    this.pendingUpdates.set(key, { update, priority });\n  }\n  \n  private processPendingUpdates() {\n    // Sort updates by priority\n    const updates = Array.from(this.pendingUpdates.entries())\n      .sort((a, b) => a[1].priority - b[1].priority);\n    \n    // Execute updates\n    updates.forEach(([key, { update }]) => {\n      try {\n        update();\n      } catch (error) {\n        console.error(`[ProfileOptimizer] Error applying ${key}:`, error);\n      }\n    });\n    \n    this.pendingUpdates.clear();\n    this.updateFrameId = null;\n  }\n  \n  private showTransitionEffect(_gridApi: GridApi) {\n    // Get the grid wrapper element\n    const gridElement = document.querySelector('.ag-root-wrapper') as HTMLElement;\n    if (!gridElement) return;\n    \n    // Use CSS classes for better performance\n    gridElement.classList.add('profile-switching');\n    \n    // Remove class after animation completes\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => {\n        gridElement.classList.remove('profile-switching');\n      });\n    });\n  }\n  \n  private hashObject(obj: any): string {\n    return JSON.stringify(obj).split('').reduce((a, b) => {\n      a = ((a << 5) - a) + b.charCodeAt(0);\n      return a & a;\n    }, 0).toString(36);\n  }\n  \n  // Clear cache for a specific profile\n  clearCache(profileId?: string) {\n    if (profileId) {\n      this.cache.delete(profileId);\n    } else {\n      this.cache.clear();\n    }\n  }\n  \n  // Preload all profiles\n  async preloadAllProfiles(profiles: GridProfile[]) {\n    // Process profiles in batches during idle time\n    const batchSize = 2;\n    for (let i = 0; i < profiles.length; i += batchSize) {\n      const batch = profiles.slice(i, i + batchSize);\n      \n      if ('requestIdleCallback' in window) {\n        await new Promise(resolve => {\n          requestIdleCallback(() => {\n            batch.forEach(profile => this.processProfile(profile));\n            resolve(undefined);\n          }, { timeout: 1000 });\n        });\n      } else {\n        batch.forEach(profile => this.processProfile(profile));\n        await new Promise(resolve => setTimeout(resolve, 50));\n      }\n    }\n  }\n}\n\nexport const profileOptimizer = new ProfileOptimizer();\n\n// Export to window for debugging\nif (typeof window !== 'undefined') {\n  (window as any).profileOptimizer = profileOptimizer;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/stores/columnSerializer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":145,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3868,3871],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3868,3871],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":234,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":234,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6880,6883],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6880,6883],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":235,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":235,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6943,6946],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6943,6946],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":260,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":260,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7664,7667],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7664,7667],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":261,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":261,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7744,7747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7744,7747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":269,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":269,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8037,8040],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8037,8040],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":301,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":301,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8926,8929],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8926,8929],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":302,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":302,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8998,9001],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8998,9001],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":303,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":303,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9069,9072],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9069,9072],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":304,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":304,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9148,9151],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9148,9151],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":409,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":409,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13637,13640],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13637,13640],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":422,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":422,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14202,14205],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14202,14205],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":436,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":436,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14828,14831],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14828,14831],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":437,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":437,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14893,14896],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14893,14896],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":561,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":561,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19669,19672],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19669,19672],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":562,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":562,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19734,19737],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19734,19737],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":563,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":563,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19808,19811],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19808,19811],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":17,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ColDef } from 'ag-grid-community';\nimport { createExcelFormatter, createCellStyleFunction } from '@/components/datatable/utils/formatters';\nimport { hasConditionalStyling } from '@/components/datatable/utils/styleUtils';\n\n// Minimal types for visual formatter data (to avoid circular imports)\ninterface SerializedFormattingRule {\n  id: string;\n  condition: {\n    type: 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'greaterThan' | 'lessThan' | 'greaterEqual' | 'lessEqual' | 'between' | 'isEmpty' | 'isNotEmpty';\n    value: string;\n    value2?: string;\n  };\n  display: {\n    type: 'text' | 'original' | 'custom';\n    text: string;\n  };\n  styling: {\n    backgroundColor?: string;\n    textColor?: string;\n    fontSize?: number;\n    fontWeight?: 'normal' | 'bold' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\n    fontStyle?: 'normal' | 'italic';\n    textDecoration?: 'none' | 'underline' | 'line-through';\n    textAlign?: 'left' | 'center' | 'right';\n    border?: {\n      width: number;\n      style: 'solid' | 'dashed' | 'dotted' | 'double';\n      color: string;\n      sides: {\n        top: boolean;\n        right: boolean;\n        bottom: boolean;\n        left: boolean;\n      };\n    };\n    padding?: {\n      top: number;\n      right: number;\n      bottom: number;\n      left: number;\n    };\n  };\n  enabled: boolean;\n}\n\ninterface SerializedDefaultFallback {\n  display: {\n    type: 'original' | 'text';\n    text: string;\n  };\n  styling: {\n    backgroundColor?: string;\n    textColor?: string;\n    fontSize?: number;\n    fontWeight?: 'normal' | 'bold' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\n    fontStyle?: 'normal' | 'italic';\n    textDecoration?: 'none' | 'underline' | 'line-through';\n    textAlign?: 'left' | 'center' | 'right';\n    border?: {\n      width: number;\n      style: 'solid' | 'dashed' | 'dotted' | 'double';\n      color: string;\n      sides: {\n        top: boolean;\n        right: boolean;\n        bottom: boolean;\n        left: boolean;\n      };\n    };\n    padding?: {\n      top: number;\n      right: number;\n      bottom: number;\n      left: number;\n    };\n  };\n}\n\n// Type for serialized column customizations\nexport interface ColumnCustomization {\n  // Identity\n  field: string;\n  \n  // Basic properties (only if changed from defaults)\n  headerName?: string;\n  width?: number;\n  minWidth?: number;\n  maxWidth?: number;\n  flex?: number;\n  \n  // Boolean flags (only if changed from defaults)\n  sortable?: boolean;\n  resizable?: boolean;\n  editable?: boolean;\n  filter?: boolean;\n  floatingFilter?: boolean;\n  hide?: boolean;\n  lockPosition?: boolean;\n  lockVisible?: boolean;\n  lockPinned?: boolean;\n  suppressHeaderMenuButton?: boolean;\n  \n  // Positioning\n  pinned?: 'left' | 'right' | null;\n  \n  // Styles (serialized format)\n  cellStyle?: {\n    type: 'static' | 'function';\n    value?: React.CSSProperties;\n    formatString?: string; // For conditional formatting\n    baseStyle?: React.CSSProperties;\n  };\n  headerStyle?: {\n    type: 'static' | 'function';\n    regular?: React.CSSProperties;\n    floating?: React.CSSProperties | null;\n  };\n  \n  // CSS Classes\n  cellClass?: string | string[];\n  headerClass?: string | string[];\n  \n  // Formatters (metadata only)\n  valueFormatter?: {\n    type: 'excel' | 'visual' | 'custom';\n    formatString?: string;\n    // Visual editor data (for full round-trip editing)\n    rules?: SerializedFormattingRule[];\n    defaultFallback?: SerializedDefaultFallback;\n  };\n  \n  // Cell data type\n  cellDataType?: 'text' | 'number' | 'date' | 'boolean';\n  \n  // Other commonly customized properties\n  headerTooltip?: string;\n  tooltipField?: string;\n  headerCheckboxSelection?: boolean;\n  checkboxSelection?: boolean;\n  rowGroup?: boolean;\n  pivot?: boolean;\n  aggFunc?: string | null;\n  \n  // Alignment classes\n  cellClassRules?: Record<string, any>;\n}\n\n// Default values for comparison\nconst COLUMN_DEFAULTS: Partial<ColDef> = {\n  sortable: true,\n  resizable: true,\n  filter: true,\n  floatingFilter: true,\n  editable: false,\n  hide: false,\n  lockPosition: false,\n  lockVisible: false,\n  lockPinned: false,\n  suppressHeaderMenuButton: false,\n  minWidth: 100,\n};\n\n/**\n * Extract only the customized properties from a column definition\n */\nfunction extractCustomizations(col: ColDef, baseCol?: ColDef): ColumnCustomization {\n  const customization: ColumnCustomization = {\n    field: col.field!,\n  };\n  \n  // Compare against base column or defaults\n  const compareBase = baseCol || COLUMN_DEFAULTS;\n  \n  // Basic properties\n  if (col.headerName !== baseCol?.headerName && col.headerName !== col.field) {\n    customization.headerName = col.headerName;\n  }\n  \n  // Width properties\n  if (col.width !== undefined && col.width !== compareBase.width) {\n    customization.width = col.width;\n  }\n  if (col.minWidth !== undefined && col.minWidth !== compareBase.minWidth) {\n    customization.minWidth = col.minWidth;\n  }\n  if (col.maxWidth !== undefined && col.maxWidth !== compareBase.maxWidth) {\n    customization.maxWidth = col.maxWidth;\n  }\n  if (col.flex !== undefined && col.flex !== compareBase.flex) {\n    customization.flex = col.flex;\n  }\n  \n  // Boolean flags - only save if different from defaults\n  if (col.sortable !== undefined && col.sortable !== compareBase.sortable) {\n    customization.sortable = col.sortable;\n  }\n  if (col.resizable !== undefined && col.resizable !== compareBase.resizable) {\n    customization.resizable = col.resizable;\n  }\n  if (col.editable !== undefined && col.editable !== compareBase.editable) {\n    customization.editable = col.editable;\n  }\n  if (col.filter !== undefined && col.filter !== compareBase.filter) {\n    customization.filter = col.filter;\n  }\n  if (col.floatingFilter !== undefined && col.floatingFilter !== compareBase.floatingFilter) {\n    customization.floatingFilter = col.floatingFilter;\n  }\n  if (col.hide !== undefined && col.hide !== compareBase.hide) {\n    customization.hide = col.hide;\n  }\n  if (col.lockPosition !== undefined && col.lockPosition !== compareBase.lockPosition) {\n    customization.lockPosition = col.lockPosition;\n  }\n  if (col.lockVisible !== undefined && col.lockVisible !== compareBase.lockVisible) {\n    customization.lockVisible = col.lockVisible;\n  }\n  if (col.lockPinned !== undefined && col.lockPinned !== compareBase.lockPinned) {\n    customization.lockPinned = col.lockPinned;\n  }\n  if (col.suppressHeaderMenuButton !== undefined && col.suppressHeaderMenuButton !== compareBase.suppressHeaderMenuButton) {\n    customization.suppressHeaderMenuButton = col.suppressHeaderMenuButton;\n  }\n  \n  // Positioning\n  if (col.pinned !== undefined && col.pinned !== null) {\n    customization.pinned = col.pinned;\n  }\n  \n  // Cell style\n  if (col.cellStyle) {\n    if (typeof col.cellStyle === 'function') {\n      // Check if it has our metadata\n      const metadata = (col.cellStyle as any).__formatString;\n      const baseStyle = (col.cellStyle as any).__baseStyle;\n      console.log('[ColumnSerializer] Saving cellStyle function:', {\n        field: col.field,\n        hasMetadata: !!metadata,\n        formatString: metadata,\n        hasBaseStyle: !!baseStyle,\n        baseStyle\n      });\n      customization.cellStyle = {\n        type: 'function',\n        formatString: metadata,\n        baseStyle: baseStyle\n      };\n    } else {\n      customization.cellStyle = {\n        type: 'static',\n        value: col.cellStyle as React.CSSProperties\n      };\n    }\n  }\n  \n  // Header style\n  if (col.headerStyle) {\n    if (typeof col.headerStyle === 'function') {\n      // Try to extract the style config if it's our custom format\n      const testRegular = (col.headerStyle as any)({ floatingFilter: false });\n      const testFloating = (col.headerStyle as any)({ floatingFilter: true });\n      \n      customization.headerStyle = {\n        type: 'function',\n        regular: testRegular || undefined,\n        floating: testFloating || undefined\n      };\n    } else if (typeof col.headerStyle === 'object') {\n      const styleObj = col.headerStyle as any;\n      if (styleObj._isHeaderStyleConfig) {\n        customization.headerStyle = {\n          type: 'function',\n          regular: styleObj.regular,\n          floating: styleObj.floating\n        };\n      } else {\n        customization.headerStyle = {\n          type: 'static',\n          regular: col.headerStyle as React.CSSProperties\n        };\n      }\n    }\n  }\n  \n  // CSS Classes\n  if (col.cellClass) {\n    customization.cellClass = col.cellClass;\n  }\n  if (col.headerClass) {\n    customization.headerClass = col.headerClass;\n  }\n  \n  // Value formatter\n  if (col.valueFormatter) {\n    console.log('[ColumnSerializer] Processing valueFormatter for field:', col.field, {\n      type: typeof col.valueFormatter,\n      isFunction: typeof col.valueFormatter === 'function'\n    });\n    \n    if (typeof col.valueFormatter === 'function') {\n      const formatString = (col.valueFormatter as any).__formatString;\n      const formatterType = (col.valueFormatter as any).__formatterType;\n      const visualRules = (col.valueFormatter as any).__visualRules;\n      const visualDefaultFallback = (col.valueFormatter as any).__visualDefaultFallback;\n      \n      console.log('[ColumnSerializer] Function formatter metadata:', {\n        field: col.field,\n        hasFormatString: !!formatString,\n        formatString: formatString,\n        formatterType: formatterType,\n        hasVisualRules: !!visualRules,\n        hasDefaultFallback: !!visualDefaultFallback\n      });\n      \n      if (formatString) {\n        customization.valueFormatter = {\n          type: formatterType || 'excel',\n          formatString,\n          // Include visual editor data if available\n          ...(visualRules && { rules: visualRules }),\n          ...(visualDefaultFallback && { defaultFallback: visualDefaultFallback })\n        };\n        console.log('[ColumnSerializer] ✅ Serialized formatter for field:', col.field);\n      } else {\n        console.warn('[ColumnSerializer] ⚠️ Formatter function has no __formatString metadata for field:', col.field);\n        // Try to serialize as custom formatter without format string\n        customization.valueFormatter = {\n          type: 'custom',\n          formatString: `// Custom formatter function for ${col.field}\\n// (Function body not serializable)`\n        };\n        console.log('[ColumnSerializer] ⚠️ Serialized as custom formatter without metadata for field:', col.field);\n      }\n    } else if (typeof col.valueFormatter === 'object') {\n      // Handle saved formatter config\n      const config = col.valueFormatter as Record<string, unknown>;\n      console.log('[ColumnSerializer] Object formatter config:', config);\n      \n      if (config._isFormatterConfig) {\n        customization.valueFormatter = {\n          type: (config.type as 'excel' | 'visual' | 'custom') || 'excel',\n          formatString: config.formatString as string,\n          ...(config.rules && { rules: config.rules as SerializedFormattingRule[] }),\n          ...(config.defaultFallback && { defaultFallback: config.defaultFallback as SerializedDefaultFallback })\n        };\n        console.log('[ColumnSerializer] ✅ Serialized object formatter for field:', col.field);\n      } else {\n        console.warn('[ColumnSerializer] ⚠️ Object formatter is not a recognized config for field:', col.field);\n      }\n    } else {\n      console.warn('[ColumnSerializer] ⚠️ Unknown formatter type for field:', col.field, typeof col.valueFormatter);\n    }\n  }\n  \n  // Cell data type\n  if (col.cellDataType && col.cellDataType !== baseCol?.cellDataType) {\n    customization.cellDataType = col.cellDataType;\n  }\n  \n  // Other properties\n  if (col.headerTooltip) customization.headerTooltip = col.headerTooltip;\n  if (col.tooltipField) customization.tooltipField = col.tooltipField;\n  if (col.headerCheckboxSelection !== undefined) customization.headerCheckboxSelection = col.headerCheckboxSelection;\n  if (col.checkboxSelection !== undefined) customization.checkboxSelection = col.checkboxSelection;\n  if (col.rowGroup !== undefined) customization.rowGroup = col.rowGroup;\n  if (col.pivot !== undefined) customization.pivot = col.pivot;\n  if (col.aggFunc !== undefined) customization.aggFunc = col.aggFunc;\n  if (col.cellClassRules) customization.cellClassRules = col.cellClassRules;\n  \n  return customization;\n}\n\n/**\n * Serialize column customizations - only saves properties that differ from defaults\n */\nexport function serializeColumnCustomizations(\n  columns: ColDef[], \n  baseColumns?: ColDef[]\n): Record<string, ColumnCustomization> {\n  const customizations: Record<string, ColumnCustomization> = {};\n  \n  columns.forEach((col, _index) => {\n    if (!col.field) return;\n    \n    const baseCol = baseColumns?.find(base => base.field === col.field);\n    const extracted = extractCustomizations(col, baseCol);\n    \n    // Only include if there are actual customizations beyond the field\n    if (Object.keys(extracted).length > 1) {\n      customizations[col.field] = extracted;\n    }\n  });\n  \n  return customizations;\n}\n\n\n/**\n * Ensure a column has a cellStyle function if its valueFormatter has conditional styling\n */\nfunction ensureCellStyleForConditionalFormatting(merged: ColDef, _custom: ColumnCustomization): void {\n  console.log('[ensureCellStyleForConditionalFormatting] Checking column:', {\n    field: merged.field,\n    hasValueFormatter: !!merged.valueFormatter,\n    valueFormatterType: typeof merged.valueFormatter\n  });\n  \n  // Check if valueFormatter has conditional styling\n  if (merged.valueFormatter && typeof merged.valueFormatter === 'function') {\n    const formatString = (merged.valueFormatter as any).__formatString;\n    \n    console.log('[ensureCellStyleForConditionalFormatting] valueFormatter details:', {\n      field: merged.field,\n      hasFormatString: !!formatString,\n      formatString: formatString,\n      hasConditionalStyling: formatString ? hasConditionalStyling(formatString) : false\n    });\n    \n    if (formatString && hasConditionalStyling(formatString)) {\n      // Check if cellStyle already exists and is properly configured\n      if (!merged.cellStyle || \n          (typeof merged.cellStyle === 'function' && \n           (merged.cellStyle as any).__formatString !== formatString)) {\n        \n        console.log('[ensureCellStyleForConditionalFormatting] Creating cellStyle:', {\n          field: merged.field,\n          formatString,\n          hasExistingCellStyle: !!merged.cellStyle,\n          existingCellStyleType: typeof merged.cellStyle\n        });\n        \n        // Extract base style if it exists\n        let baseStyle: React.CSSProperties = {};\n        if (merged.cellStyle) {\n          if (typeof merged.cellStyle === 'object') {\n            baseStyle = merged.cellStyle;\n          } else if (typeof merged.cellStyle === 'function' && (merged.cellStyle as any).__baseStyle) {\n            baseStyle = (merged.cellStyle as any).__baseStyle;\n          }\n        }\n        \n        // Create cellStyle function\n        const styleFunc = createCellStyleFunction(formatString, baseStyle);\n        \n        // Attach metadata for future serialization\n        Object.defineProperty(styleFunc, '__formatString', { \n          value: formatString, \n          writable: false,\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(styleFunc, '__baseStyle', { \n          value: baseStyle, \n          writable: false,\n          enumerable: false,\n          configurable: true\n        });\n        \n        merged.cellStyle = styleFunc;\n      }\n    }\n  }\n}\n\n/**\n * Apply customizations to base columns\n */\nexport function deserializeColumnCustomizations(\n  customizations: Record<string, ColumnCustomization>,\n  baseColumns: ColDef[]\n): ColDef[] {\n  // Handle case where baseColumns is empty\n  if (!baseColumns || baseColumns.length === 0) {\n    console.warn('[ColumnSerializer] No base columns provided for deserialization');\n    return [];\n  }\n  \n  return baseColumns.map(baseCol => {\n    const field = baseCol.field;\n    if (!field || !customizations[field]) {\n      // Apply defaults even if no customizations\n      return {\n        ...baseCol,\n        ...COLUMN_DEFAULTS\n      };\n    }\n    \n    const custom = customizations[field];\n    // Start with base column merged with defaults\n    const merged: ColDef = { \n      ...COLUMN_DEFAULTS,\n      ...baseCol \n    };\n    \n    // Apply basic properties\n    if (custom.headerName !== undefined) merged.headerName = custom.headerName;\n    if (custom.width !== undefined) merged.width = custom.width;\n    if (custom.minWidth !== undefined) merged.minWidth = custom.minWidth;\n    if (custom.maxWidth !== undefined) merged.maxWidth = custom.maxWidth;\n    if (custom.flex !== undefined) merged.flex = custom.flex;\n    \n    // Apply boolean flags\n    if (custom.sortable !== undefined) merged.sortable = custom.sortable;\n    if (custom.resizable !== undefined) merged.resizable = custom.resizable;\n    if (custom.editable !== undefined) merged.editable = custom.editable;\n    if (custom.filter !== undefined) merged.filter = custom.filter;\n    if (custom.floatingFilter !== undefined) merged.floatingFilter = custom.floatingFilter;\n    // Don't apply hide property from customizations - column visibility should be controlled by column state only\n    // if (custom.hide !== undefined) merged.hide = custom.hide;\n    if (custom.lockPosition !== undefined) merged.lockPosition = custom.lockPosition;\n    if (custom.lockVisible !== undefined) merged.lockVisible = custom.lockVisible;\n    if (custom.lockPinned !== undefined) merged.lockPinned = custom.lockPinned;\n    if (custom.suppressHeaderMenuButton !== undefined) merged.suppressHeaderMenuButton = custom.suppressHeaderMenuButton;\n    \n    // Apply positioning\n    if (custom.pinned !== undefined) merged.pinned = custom.pinned;\n    \n    // Apply cell style\n    if (custom.cellStyle) {\n      if (custom.cellStyle.type === 'static' && custom.cellStyle.value) {\n        merged.cellStyle = custom.cellStyle.value;\n      } else if (custom.cellStyle.type === 'function' && custom.cellStyle.formatString) {\n        console.log('[ColumnSerializer] Loading cellStyle function:', {\n          field,\n          formatString: custom.cellStyle.formatString,\n          hasBaseStyle: !!custom.cellStyle.baseStyle,\n          baseStyle: custom.cellStyle.baseStyle\n        });\n        // Recreate the cell style function\n        const styleFunc = createCellStyleFunction(custom.cellStyle.formatString, custom.cellStyle.baseStyle);\n        // Attach metadata for future serialization\n        Object.defineProperty(styleFunc, '__formatString', { \n          value: custom.cellStyle.formatString, \n          writable: false,\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(styleFunc, '__baseStyle', { \n          value: custom.cellStyle.baseStyle, \n          writable: false,\n          enumerable: false,\n          configurable: true\n        });\n        merged.cellStyle = styleFunc;\n      }\n    }\n    \n    // Apply header style\n    if (custom.headerStyle) {\n      if (custom.headerStyle.type === 'static' && custom.headerStyle.regular) {\n        merged.headerStyle = custom.headerStyle.regular;\n      } else if (custom.headerStyle.type === 'function') {\n        // Create the header style function\n        merged.headerStyle = (params: { floatingFilter?: boolean }) => {\n          if (params?.floatingFilter) {\n            return custom.headerStyle?.floating || null;\n          }\n          return custom.headerStyle?.regular || null;\n        };\n        \n        // Also store as object format for persistence\n        (merged.headerStyle as any)._isHeaderStyleConfig = true;\n        (merged.headerStyle as any).regular = custom.headerStyle.regular;\n        (merged.headerStyle as any).floating = custom.headerStyle.floating;\n      }\n    }\n    \n    // Apply CSS classes\n    if (custom.cellClass !== undefined) merged.cellClass = custom.cellClass;\n    if (custom.headerClass !== undefined) merged.headerClass = custom.headerClass;\n    \n    // Apply value formatter\n    if (custom.valueFormatter && custom.valueFormatter.formatString) {\n      if (custom.valueFormatter.type === 'excel' || custom.valueFormatter.type === 'visual') {\n        console.log('[ColumnSerializer] Recreating formatter for field:', field, {\n          formatString: custom.valueFormatter.formatString,\n          type: custom.valueFormatter.type,\n          hasRules: !!custom.valueFormatter.rules,\n          hasDefaultFallback: !!custom.valueFormatter.defaultFallback\n        });\n        const formatter = createExcelFormatter(custom.valueFormatter.formatString);\n        \n        // Attach visual editor metadata if available\n        if (custom.valueFormatter.rules) {\n          Object.defineProperty(formatter, '__visualRules', { \n            value: custom.valueFormatter.rules, \n            writable: false,\n            enumerable: false,\n            configurable: true\n          });\n        }\n        \n        if (custom.valueFormatter.defaultFallback) {\n          Object.defineProperty(formatter, '__visualDefaultFallback', { \n            value: custom.valueFormatter.defaultFallback, \n            writable: false,\n            enumerable: false,\n            configurable: true\n          });\n        }\n        \n        merged.valueFormatter = formatter;\n        // Value formatter will be used for export automatically\n      }\n    }\n    \n    // Apply cell data type\n    if (custom.cellDataType !== undefined) merged.cellDataType = custom.cellDataType;\n    \n    // Apply other properties\n    if (custom.headerTooltip !== undefined) merged.headerTooltip = custom.headerTooltip;\n    if (custom.tooltipField !== undefined) merged.tooltipField = custom.tooltipField;\n    if (custom.headerCheckboxSelection !== undefined) merged.headerCheckboxSelection = custom.headerCheckboxSelection;\n    if (custom.checkboxSelection !== undefined) merged.checkboxSelection = custom.checkboxSelection;\n    if (custom.rowGroup !== undefined) merged.rowGroup = custom.rowGroup;\n    if (custom.pivot !== undefined) merged.pivot = custom.pivot;\n    if (custom.aggFunc !== undefined) merged.aggFunc = custom.aggFunc;\n    if (custom.cellClassRules !== undefined) merged.cellClassRules = custom.cellClassRules;\n    \n    // Ensure cellStyle is created if valueFormatter has conditional styling\n    ensureCellStyleForConditionalFormatting(merged, custom);\n    \n    return merged;\n  });\n}\n\n/**\n * Calculate the size of serialized customizations in bytes\n */\nexport function calculateCustomizationSize(customizations: Record<string, ColumnCustomization>): number {\n  return JSON.stringify(customizations).length;\n}\n\n/**\n * Get a summary of what's customized\n */\nexport function getCustomizationSummary(customizations: Record<string, ColumnCustomization>): {\n  totalColumns: number;\n  customizedColumns: number;\n  properties: Record<string, number>;\n} {\n  const propertyCount: Record<string, number> = {};\n  \n  Object.values(customizations).forEach(custom => {\n    Object.keys(custom).forEach(key => {\n      if (key !== 'field') {\n        propertyCount[key] = (propertyCount[key] || 0) + 1;\n      }\n    });\n  });\n  \n  return {\n    totalColumns: Object.keys(customizations).length,\n    customizedColumns: Object.keys(customizations).length,\n    properties: propertyCount\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/stores/migrateProfiles.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3118,3121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3118,3121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":93,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3187,3190],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3187,3190],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useProfileStore } from './profile.store';\nimport { logStorageAnalysis } from './storageAnalyzer';\n\n/**\n * Migrate all profiles to use lightweight column serialization\n * This will convert all existing profiles that still use full columnDefs\n * to the new lightweight format\n */\nexport function migrateAllProfilesToLightweight() {\n  const store = useProfileStore.getState();\n  const profiles = store.profiles;\n  \n  console.group('🔄 Migrating profiles to lightweight format');\n  \n  let migratedCount = 0;\n  \n  profiles.forEach(profile => {\n    // Check if profile has full columnDefs but no lightweight format\n    if (profile.gridState.columnDefs && \n        profile.gridState.columnDefs.length > 0 && \n        !profile.gridState.columnCustomizations) {\n      \n      console.log(`📦 Migrating profile: ${profile.name} (${profile.id})`);\n      \n      // Get the column definitions using the store method (handles all formats)\n      const columnDefs = store.getColumnDefs(profile.id);\n      \n      if (columnDefs) {\n        // Save using the lightweight format\n        // We need to temporarily set this as the active profile to use saveColumnCustomizations\n        const currentActiveId = store.activeProfileId;\n        store.setActiveProfile(profile.id);\n        \n        // Save the columns in lightweight format\n        store.saveColumnCustomizations(columnDefs, columnDefs);\n        \n        // Restore the previous active profile\n        store.setActiveProfile(currentActiveId);\n        \n        migratedCount++;\n        console.log(`✅ Successfully migrated profile: ${profile.name}`);\n      }\n    } else if (profile.gridState.columnCustomizations) {\n      console.log(`⏭️  Profile already using lightweight format: ${profile.name}`);\n    } else {\n      console.log(`⏭️  Profile has no column definitions: ${profile.name}`);\n    }\n  });\n  \n  console.log(`\\n📊 Migration complete: ${migratedCount} profiles migrated`);\n  console.groupEnd();\n  \n  // Show storage analysis after migration\n  console.log('\\n');\n  logStorageAnalysis();\n}\n\n/**\n * Force refresh all profiles to ensure they're using the latest format\n * This will reload column definitions and re-save them\n */\nexport function refreshAllProfiles() {\n  const store = useProfileStore.getState();\n  const profiles = store.profiles;\n  const currentActiveId = store.activeProfileId;\n  \n  console.group('🔄 Refreshing all profiles');\n  \n  profiles.forEach(profile => {\n    const columnDefs = store.getColumnDefs(profile.id);\n    if (columnDefs && columnDefs.length > 0) {\n      console.log(`🔧 Refreshing profile: ${profile.name}`);\n      \n      // Temporarily switch to this profile\n      store.setActiveProfile(profile.id);\n      \n      // Re-save with current format\n      store.saveColumnCustomizations(columnDefs, profile.gridState.baseColumnDefs || columnDefs);\n      \n      console.log(`✅ Refreshed: ${profile.name}`);\n    }\n  });\n  \n  // Restore original active profile\n  store.setActiveProfile(currentActiveId);\n  \n  console.groupEnd();\n}\n\n// Export functions to window for easy console access\nif (typeof window !== 'undefined') {\n  (window as any).migrateProfiles = migrateAllProfilesToLightweight;\n  (window as any).refreshProfiles = refreshAllProfiles;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/stores/profile.store.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":120,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":120,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3891,3894],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3891,3894],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":132,"column":94,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":97,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4445,4448],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4445,4448],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":138,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4682,4685],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4682,4685],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { ColDef, ColumnState, FilterModel, SortModelItem } from 'ag-grid-community';\nimport { ColumnCustomization, serializeColumnCustomizations, deserializeColumnCustomizations } from './columnSerializer';\n\ninterface PersistedState {\n  profiles?: GridProfile[];\n  activeProfileId?: string;\n  lastExportedAt?: number;\n  autoSave?: boolean;\n}\n\n// Profile data structure\nexport interface GridProfile {\n  id: string;\n  name: string;\n  createdAt: number;\n  updatedAt: number;\n  isDefault?: boolean;\n  description?: string;\n  gridState: {\n    // Column definitions with all customizations (legacy - for backward compatibility)\n    columnDefs?: ColDef[];\n    // Lightweight column customizations (new format)\n    columnCustomizations?: Record<string, ColumnCustomization>;\n    // Base column definitions snapshot (for reference)\n    baseColumnDefs?: ColDef[];\n    // Column state (order, visibility, width, etc.)\n    columnState: ColumnState[];\n    // Filter model\n    filterModel: FilterModel;\n    // Sort model\n    sortModel: SortModelItem[];\n    // Templates\n    templates?: Record<string, unknown>[];\n    // Column customization templates\n    columnTemplates?: Record<string, unknown>[];\n    // UI preferences\n    font?: string;\n    // Other grid options\n    gridOptions?: {\n      rowHeight?: number;\n      headerHeight?: number;\n      floatingFiltersHeight?: number;\n      groupHeaderHeight?: number;\n      pivotHeaderHeight?: number;\n      pivotGroupHeaderHeight?: number;\n      animateRows?: boolean;\n      pagination?: boolean;\n      paginationPageSize?: number;\n    };\n  };\n}\n\ninterface ProfileStore {\n  // Profiles\n  profiles: GridProfile[];\n  activeProfileId: string;\n  \n  // Migration state\n  migrationPending: boolean;\n  migrationInProgress: boolean;\n  \n  // Actions\n  createProfile: (name: string, description?: string) => GridProfile;\n  updateProfile: (profileId: string, updates: Partial<GridProfile>) => void;\n  deleteProfile: (profileId: string) => void;\n  renameProfile: (profileId: string, newName: string) => void;\n  setActiveProfile: (profileId: string) => void;\n  getActiveProfile: () => GridProfile | undefined;\n  duplicateProfile: (profileId: string, newName: string) => GridProfile;\n  importProfile: (profileData: GridProfile) => void;\n  exportProfile: (profileId: string) => GridProfile | undefined;\n  saveCurrentState: (gridState: Partial<GridProfile['gridState']>) => void;\n  \n  // Lightweight column serialization\n  saveColumnCustomizations: (columnDefs: ColDef[], baseColumnDefs?: ColDef[]) => void;\n  getColumnDefs: (profileId?: string) => ColDef[] | undefined;\n  \n  // Auto-save\n  autoSave: boolean;\n  setAutoSave: (enabled: boolean) => void;\n  \n  // Migration\n  performDeferredMigration: () => Promise<void>;\n}\n\n// Default profile ID\nconst DEFAULT_PROFILE_ID = 'default-profile';\n\n// Create default profile\nconst createDefaultProfile = (): GridProfile => ({\n  id: DEFAULT_PROFILE_ID,\n  name: 'Default',\n  createdAt: Date.now(),\n  updatedAt: Date.now(),\n  isDefault: true,\n  gridState: {\n    columnCustomizations: {},\n    columnState: [],\n    filterModel: {},\n    sortModel: []\n  }\n});\n\n// Deferred migration function\nasync function performMigration(state: PersistedState): Promise<PersistedState> {\n        // perfMonitor.mark('migration-start');\n  \n  const newState = { ...state };\n  \n  // Migrate from version 1 to 2 (clean invalid properties)\n  if (state.profiles && Array.isArray(state.profiles)) {\n    newState.profiles = state.profiles.map((profile: GridProfile) => {\n      const newProfile = { ...profile };\n      \n      if (profile.gridState && profile.gridState.columnDefs) {\n        // Clean invalid properties from each column definition\n        newProfile.gridState.columnDefs = profile.gridState.columnDefs.map((col: ColDef) => {\n          const cleaned = { ...col } as any;\n          // Remove invalid properties that AG-Grid doesn't recognize\n          delete cleaned.valueFormat;\n          delete cleaned._hasFormatter;\n          delete cleaned.excelFormat;\n          return cleaned;\n        });\n      }\n      \n      // Convert headerStyle objects to new format\n      if (newProfile.gridState && newProfile.gridState.columnDefs) {\n        newProfile.gridState.columnDefs = newProfile.gridState.columnDefs.map((col: ColDef) => {\n          if (col.headerStyle && typeof col.headerStyle === 'object' && !(col.headerStyle as any)._isHeaderStyleConfig) {\n            // Convert old format to new format\n            col.headerStyle = {\n              _isHeaderStyleConfig: true,\n              regular: col.headerStyle,\n              floating: null\n            } as any;\n          }\n          return col;\n        });\n      }\n      \n      // Convert to lightweight format if needed\n      if (newProfile.gridState && newProfile.gridState.columnDefs && \n          newProfile.gridState.columnDefs.length > 0 && \n          !newProfile.gridState.columnCustomizations) {\n        \n        const baseColumns = newProfile.gridState.columnDefs.map((col: ColDef) => ({\n          field: col.field,\n          headerName: col.field,\n          cellDataType: col.cellDataType\n        }));\n        \n        const customizations = serializeColumnCustomizations(newProfile.gridState.columnDefs, baseColumns);\n        \n        console.log('[ProfileStore Migration] Converting profile to lightweight format:', {\n          profileId: newProfile.id,\n          profileName: newProfile.name,\n          originalSize: JSON.stringify(newProfile.gridState.columnDefs).length,\n          newSize: JSON.stringify(customizations).length,\n          reduction: `${Math.round((1 - JSON.stringify(customizations).length / JSON.stringify(newProfile.gridState.columnDefs).length) * 100)}%`\n        });\n        \n        // Update to new format\n        newProfile.gridState.columnCustomizations = customizations;\n        newProfile.gridState.baseColumnDefs = baseColumns;\n        // Remove legacy columnDefs after migration\n        delete newProfile.gridState.columnDefs;\n      }\n      \n      return newProfile;\n    });\n  }\n  \n      // perfMonitor.mark('migration-end');\n    // perfMonitor.measure('migrationTime', 'migration-start', 'migration-end');\n  \n  return newState;\n}\n\nexport const useProfileStore = create<ProfileStore>()(\n  persist(\n    (set, get) => ({\n      // Initial state\n      profiles: [createDefaultProfile()],\n      activeProfileId: DEFAULT_PROFILE_ID,\n      autoSave: true,\n      migrationPending: false,\n      migrationInProgress: false,\n      \n      // Create new profile\n      createProfile: (name, description) => {\n        const state = get();\n        \n        // Get the default profile to clone its grid state\n        const defaultProfile = state.profiles.find(p => p.id === DEFAULT_PROFILE_ID);\n        \n        const newProfile: GridProfile = {\n          id: `profile-${Date.now()}`,\n          name,\n          description,\n          createdAt: Date.now(),\n          updatedAt: Date.now(),\n          gridState: defaultProfile?.gridState ? {\n            // Clone the default profile's grid state using new lightweight format\n            columnCustomizations: { ...(defaultProfile.gridState.columnCustomizations || {}) },\n            baseColumnDefs: [...(defaultProfile.gridState.baseColumnDefs || [])],\n            columnState: [...(defaultProfile.gridState.columnState || [])],\n            filterModel: {},  // Start with no filters\n            sortModel: []     // Start with no sorting\n          } : {\n            // Fallback to empty state if default profile not found\n            columnCustomizations: {},\n            baseColumnDefs: [],\n            columnState: [],\n            filterModel: {},\n            sortModel: []\n          }\n        };\n        \n        console.log('[ProfileStore] Creating new profile with default state:', {\n          profileName: name,\n          defaultProfileFound: !!defaultProfile,\n          customizationsCount: Object.keys(newProfile.gridState.columnCustomizations || {}).length\n        });\n        \n        set(state => ({\n          profiles: [...state.profiles, newProfile]\n        }));\n        \n        return newProfile;\n      },\n      \n      // Update existing profile\n      updateProfile: (profileId, updates) => {\n        console.log('[ProfileStore] updateProfile called:', {\n          profileId,\n          updates,\n          hasGridState: !!updates.gridState,\n          columnDefsCount: updates.gridState?.columnDefs?.length\n        });\n        \n        set(state => {\n          const updatedProfiles = state.profiles.map(profile => {\n            if (profile.id === profileId) {\n              const updatedProfile = {\n                ...profile,\n                ...updates,\n                updatedAt: Date.now(),\n                gridState: updates.gridState\n                  ? {\n                      ...profile.gridState,\n                      ...updates.gridState\n                    }\n                  : profile.gridState\n              };\n              console.log('[ProfileStore] Profile updated:', {\n                profileId,\n                profileName: updatedProfile.name,\n                columnDefsCount: updatedProfile.gridState?.columnDefs?.length,\n                hasColumnState: !!updatedProfile.gridState?.columnState\n              });\n              return updatedProfile;\n            }\n            return profile;\n          });\n          \n          return { profiles: updatedProfiles };\n        });\n      },\n      \n      // Delete profile (cannot delete default or active profile)\n      deleteProfile: (profileId) => {\n        const { activeProfileId, profiles } = get();\n        \n        // Cannot delete default profile\n        if (profileId === DEFAULT_PROFILE_ID) {\n          console.warn('Cannot delete default profile');\n          return;\n        }\n        \n        const profileToDelete = profiles.find(p => p.id === profileId);\n        if (!profileToDelete) {\n          console.warn(`Profile ${profileId} not found`);\n          return;\n        }\n        \n        console.log('[ProfileStore] Deleting profile:', {\n          profileId,\n          profileName: profileToDelete.name,\n          isActiveProfile: profileId === activeProfileId,\n          willSwitchToDefault: profileId === activeProfileId\n        });\n        \n        // If deleting active profile, switch to default\n        if (profileId === activeProfileId) {\n          console.log('[ProfileStore] Switching to default profile after deletion');\n          set({ activeProfileId: DEFAULT_PROFILE_ID });\n        }\n        \n        // Remove the profile from the list\n        set(state => ({\n          profiles: state.profiles.filter(p => p.id !== profileId)\n        }));\n        \n        console.log('[ProfileStore] Profile deleted successfully:', {\n          deletedProfile: profileToDelete.name,\n          newActiveProfileId: profileId === activeProfileId ? DEFAULT_PROFILE_ID : activeProfileId,\n          remainingProfiles: get().profiles.length\n        });\n      },\n      \n      // Rename profile\n      renameProfile: (profileId, newName) => {\n        set(state => ({\n          profiles: state.profiles.map(profile => \n            profile.id === profileId\n              ? { ...profile, name: newName, updatedAt: Date.now() }\n              : profile\n          )\n        }));\n      },\n      \n      // Set active profile\n      setActiveProfile: (profileId) => {\n        const { profiles } = get();\n        const profileExists = profiles.some(p => p.id === profileId);\n        \n        console.log('[ProfileStore] setActiveProfile called:', {\n          profileId,\n          profileExists,\n          availableProfiles: profiles.map(p => ({ id: p.id, name: p.name }))\n        });\n        \n        if (profileExists) {\n          set({ activeProfileId: profileId });\n          console.log('[ProfileStore] Active profile set to:', profileId);\n        } else {\n          console.warn(`[ProfileStore] Profile ${profileId} not found`);\n        }\n      },\n      \n      // Get active profile\n      getActiveProfile: () => {\n        const { profiles, activeProfileId } = get();\n        const activeProfile = profiles.find(p => p.id === activeProfileId);\n        \n        console.log('[ProfileStore] getActiveProfile:', {\n          activeProfileId,\n          found: !!activeProfile,\n          profileName: activeProfile?.name,\n          hasGridState: !!activeProfile?.gridState,\n          columnDefsCount: activeProfile?.gridState?.columnDefs?.length\n        });\n        \n        return activeProfile;\n      },\n      \n      // Duplicate profile\n      duplicateProfile: (profileId, newName) => {\n        const { profiles } = get();\n        const sourceProfile = profiles.find(p => p.id === profileId);\n        \n        if (!sourceProfile) {\n          throw new Error(`Profile ${profileId} not found`);\n        }\n        \n        const duplicatedProfile: GridProfile = {\n          ...JSON.parse(JSON.stringify(sourceProfile)), // Deep clone\n          id: `profile-${Date.now()}`,\n          name: newName,\n          createdAt: Date.now(),\n          updatedAt: Date.now(),\n          isDefault: false,\n        };\n        \n        set(state => ({\n          profiles: [...state.profiles, duplicatedProfile]\n        }));\n        \n        return duplicatedProfile;\n      },\n      \n      // Import profile\n      importProfile: (profileData) => {\n        const newProfile: GridProfile = {\n          ...profileData,\n          id: `profile-${Date.now()}`, // Generate new ID to avoid conflicts\n          createdAt: Date.now(),\n          updatedAt: Date.now(),\n          isDefault: false,\n        };\n        \n        set(state => ({\n          profiles: [...state.profiles, newProfile]\n        }));\n      },\n      \n      // Export profile\n      exportProfile: (profileId) => {\n        const { profiles } = get();\n        return profiles.find(p => p.id === profileId);\n      },\n      \n      // Save current state to active profile\n      saveCurrentState: (gridState) => {\n        const { activeProfileId, profiles } = get();\n        const activeProfile = profiles.find(p => p.id === activeProfileId);\n        \n        console.log('[ProfileStore] saveCurrentState called:', {\n          activeProfileId,\n          hasActiveProfile: !!activeProfile,\n          gridStateKeys: Object.keys(gridState),\n          columnDefsCount: gridState.columnDefs?.length,\n          columnStateCount: gridState.columnState?.length\n        });\n        \n        if (!activeProfile) {\n          console.warn('[ProfileStore] No active profile found for saving');\n          return;\n        }\n        \n        // If columnDefs are provided, convert to lightweight format\n        if (gridState.columnDefs) {\n          const baseColumns = activeProfile.gridState.baseColumnDefs || [];\n          const customizations = serializeColumnCustomizations(gridState.columnDefs, baseColumns);\n          \n          console.log('[ProfileStore] Converting columnDefs to lightweight format:', {\n            columnDefsCount: gridState.columnDefs.length,\n            customizationsCount: Object.keys(customizations).length,\n            sizeReduction: `${Math.round((1 - JSON.stringify(customizations).length / JSON.stringify(gridState.columnDefs).length) * 100)}%`\n          });\n          \n          get().updateProfile(activeProfileId, {\n            gridState: {\n              ...activeProfile.gridState,\n              ...gridState,\n              columnCustomizations: customizations,\n              // Keep base columns for reference (only update if not set)\n              baseColumnDefs: activeProfile.gridState.baseColumnDefs || gridState.columnDefs,\n              // Remove full columnDefs to save space\n              columnDefs: undefined\n            }\n          });\n        } else {\n          get().updateProfile(activeProfileId, {\n            gridState: {\n              ...activeProfile.gridState,\n              ...gridState\n            }\n          });\n        }\n      },\n      \n      // Save column customizations in lightweight format\n      saveColumnCustomizations: (columnDefs, baseColumnDefs) => {\n        const { activeProfileId } = get();\n        const activeProfile = get().getActiveProfile();\n        \n        if (!activeProfile) {\n          console.warn('[ProfileStore] No active profile found for saving column customizations');\n          return;\n        }\n        \n        // Ensure we have base columns - use provided ones or fall back to current columns\n        const actualBaseColumns = baseColumnDefs || activeProfile.gridState.baseColumnDefs || columnDefs;\n        \n        const customizations = serializeColumnCustomizations(\n          columnDefs, \n          actualBaseColumns\n        );\n        \n        console.log('[ProfileStore] Saving column customizations:', {\n          profileId: activeProfileId,\n          customizationsCount: Object.keys(customizations).length,\n          baseColumnsCount: actualBaseColumns.length,\n          size: `${(JSON.stringify(customizations).length / 1024).toFixed(2)}KB`\n        });\n        \n        get().updateProfile(activeProfileId, {\n          gridState: {\n            ...activeProfile.gridState,\n            columnCustomizations: customizations,\n            baseColumnDefs: actualBaseColumns,\n            // Remove legacy full columnDefs\n            columnDefs: undefined\n          }\n        });\n      },\n      \n      // Get column definitions (reconstruct from lightweight format if needed)\n      getColumnDefs: (profileId) => {\n        const { profiles, activeProfileId } = get();\n        const id = profileId || activeProfileId;\n        const profile = profiles.find(p => p.id === id);\n        \n        console.log('[ProfileStore] getColumnDefs called:', {\n          profileId,\n          activeProfileId,\n          found: !!profile,\n          profileName: profile?.name,\n          hasCustomizations: !!(profile?.gridState?.columnCustomizations),\n          hasBaseColumns: !!(profile?.gridState?.baseColumnDefs)\n        });\n        \n        if (!profile) return undefined;\n        \n        // If we have the new lightweight format with valid base columns\n        if (profile.gridState.columnCustomizations && profile.gridState.baseColumnDefs && profile.gridState.baseColumnDefs.length > 0) {\n          console.log('[ProfileStore] Reconstructing columnDefs from lightweight format', {\n            customizationsCount: Object.keys(profile.gridState.columnCustomizations).length,\n            baseColumnsCount: profile.gridState.baseColumnDefs.length\n          });\n          const reconstructed = deserializeColumnCustomizations(\n            profile.gridState.columnCustomizations,\n            profile.gridState.baseColumnDefs\n          );\n          console.log('[ProfileStore] Column definitions reconstructed:', {\n            totalColumns: reconstructed.length,\n            columnsWithFormatters: reconstructed.filter(col => col.valueFormatter).length\n          });\n          return reconstructed;\n        }\n        \n        // Fall back to legacy format if available\n        if (profile.gridState.columnDefs) {\n          console.log('[ProfileStore] Using legacy columnDefs format');\n          return profile.gridState.columnDefs;\n        }\n        \n        // Return empty array if no column definitions available\n        return [];\n      },\n      \n      // Auto-save settings\n      setAutoSave: (enabled) => {\n        set({ autoSave: enabled });\n      },\n      \n      // Perform deferred migration\n      performDeferredMigration: async () => {\n        const state = get();\n        if (state.migrationInProgress) return;\n        \n        set({ migrationInProgress: true });\n        \n        try {\n          // Get the current persisted state\n          const storageKey = 'grid-profile-storage';\n          const stored = localStorage.getItem(storageKey);\n          \n          if (stored) {\n            const parsedData = JSON.parse(stored);\n            const currentVersion = parsedData.version || 1;\n            \n            if (currentVersion < 4) {\n              console.log('[ProfileStore] Performing deferred migration from version', currentVersion);\n              \n              // Perform migration\n              const migratedState = await performMigration(parsedData.state);\n              \n              // Update the store\n              set({\n                profiles: migratedState.profiles || [createDefaultProfile()],\n                activeProfileId: migratedState.activeProfileId || DEFAULT_PROFILE_ID,\n                autoSave: migratedState.autoSave !== undefined ? migratedState.autoSave : true,\n                migrationPending: false,\n                migrationInProgress: false\n              });\n              \n              // Update localStorage with new version\n              const newData = {\n                ...parsedData,\n                version: 4,\n                state: migratedState\n              };\n              localStorage.setItem(storageKey, JSON.stringify(newData));\n              \n              console.log('[ProfileStore] Migration completed successfully');\n            }\n          }\n        } catch (error) {\n          console.error('[ProfileStore] Migration failed:', error);\n        } finally {\n          set({ migrationInProgress: false, migrationPending: false });\n        }\n      }\n    }),\n    {\n      name: 'grid-profile-storage',\n      version: 4,\n      // Skip migration during initialization - will be done on demand\n      migrate: (persistedState: unknown, version: number) => {\n        const typedState = persistedState as PersistedState;\n        if (version < 4) {\n          // Mark that migration is needed but don't do it now\n          console.log('[ProfileStore] Migration needed, will defer until after initialization');\n          return {\n            ...typedState,\n            migrationPending: true\n          };\n        }\n        return typedState;\n      },\n      // Only persist essential data\n      partialize: (state) => ({\n        profiles: state.profiles,\n        activeProfileId: state.activeProfileId,\n        autoSave: state.autoSave\n      })\n    }\n  )\n);\n\n// Convenience hooks\nexport const useProfiles = () => useProfileStore(state => state.profiles);\nexport const useActiveProfile = () => {\n  // perfMonitor.mark('profile-load-start');\n  const profile = useProfileStore(state => \n    state.profiles.find(p => p.id === state.activeProfileId)\n  );\n  // perfMonitor.mark('profile-load-end');\n  // perfMonitor.measure('profileLoadTime', 'profile-load-start', 'profile-load-end');\n  return profile;\n};\n\n// Perform migration on idle\nif (typeof window !== 'undefined') {\n  const store = useProfileStore.getState();\n  \n  if ('requestIdleCallback' in window) {\n    requestIdleCallback(() => {\n      if (store.migrationPending) {\n        store.performDeferredMigration();\n      }\n    }, { timeout: 5000 });\n  } else {\n    setTimeout(() => {\n      if (store.migrationPending) {\n        store.performDeferredMigration();\n      }\n    }, 2000);\n  }\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/stores/storageAnalyzer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":130,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4486,4489],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4486,4489],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { GridProfile } from './profile.store';\nimport { calculateCustomizationSize, getCustomizationSummary } from './columnSerializer';\n\nexport interface StorageAnalysis {\n  totalProfiles: number;\n  totalSizeKB: number;\n  profileAnalysis: {\n    profileId: string;\n    profileName: string;\n    legacySizeKB: number;\n    lightweightSizeKB: number;\n    savingsKB: number;\n    savingsPercent: number;\n    customizationSummary?: ReturnType<typeof getCustomizationSummary>;\n  }[];\n  overallSavings: {\n    totalLegacySizeKB: number;\n    totalLightweightSizeKB: number;\n    totalSavingsKB: number;\n    totalSavingsPercent: number;\n  };\n}\n\nexport function analyzeProfileStorage(): StorageAnalysis {\n  const storageKey = 'grid-profile-storage';\n  const stored = localStorage.getItem(storageKey);\n  \n  if (!stored) {\n    return {\n      totalProfiles: 0,\n      totalSizeKB: 0,\n      profileAnalysis: [],\n      overallSavings: {\n        totalLegacySizeKB: 0,\n        totalLightweightSizeKB: 0,\n        totalSavingsKB: 0,\n        totalSavingsPercent: 0\n      }\n    };\n  }\n  \n  const parsedData = JSON.parse(stored);\n  const profiles: GridProfile[] = parsedData.state?.profiles || [];\n  \n  const profileAnalysis = profiles.map(profile => {\n    // Calculate legacy size (full columnDefs)\n    const legacySize = profile.gridState.columnDefs \n      ? JSON.stringify(profile.gridState.columnDefs).length / 1024\n      : 0;\n    \n    // Calculate lightweight size\n    const lightweightSize = profile.gridState.columnCustomizations\n      ? calculateCustomizationSize(profile.gridState.columnCustomizations) / 1024\n      : 0;\n    \n    // Get customization summary if using lightweight format\n    const customizationSummary = profile.gridState.columnCustomizations\n      ? getCustomizationSummary(profile.gridState.columnCustomizations)\n      : undefined;\n    \n    const potentialSavings = legacySize > 0 ? legacySize - lightweightSize : 0;\n    const savingsPercent = legacySize > 0 ? (potentialSavings / legacySize) * 100 : 0;\n    \n    return {\n      profileId: profile.id,\n      profileName: profile.name,\n      legacySizeKB: legacySize,\n      lightweightSizeKB: lightweightSize,\n      savingsKB: potentialSavings,\n      savingsPercent,\n      customizationSummary\n    };\n  });\n  \n  const totalLegacySizeKB = profileAnalysis.reduce((sum, p) => sum + p.legacySizeKB, 0);\n  const totalLightweightSizeKB = profileAnalysis.reduce((sum, p) => sum + p.lightweightSizeKB, 0);\n  const totalSavingsKB = totalLegacySizeKB - totalLightweightSizeKB;\n  const totalSavingsPercent = totalLegacySizeKB > 0 ? (totalSavingsKB / totalLegacySizeKB) * 100 : 0;\n  \n  return {\n    totalProfiles: profiles.length,\n    totalSizeKB: stored.length / 1024,\n    profileAnalysis,\n    overallSavings: {\n      totalLegacySizeKB,\n      totalLightweightSizeKB,\n      totalSavingsKB,\n      totalSavingsPercent\n    }\n  };\n}\n\nexport function logStorageAnalysis() {\n  const analysis = analyzeProfileStorage();\n  \n  console.group('🗄️ Profile Storage Analysis');\n  console.log(`Total profiles: ${analysis.totalProfiles}`);\n  console.log(`Total storage size: ${analysis.totalSizeKB.toFixed(2)} KB`);\n  \n  console.group('📊 Profile Breakdown');\n  analysis.profileAnalysis.forEach(profile => {\n    console.group(`📁 ${profile.profileName} (${profile.profileId})`);\n    console.log(`Legacy size: ${profile.legacySizeKB.toFixed(2)} KB`);\n    console.log(`Lightweight size: ${profile.lightweightSizeKB.toFixed(2)} KB`);\n    console.log(`Savings: ${profile.savingsKB.toFixed(2)} KB (${profile.savingsPercent.toFixed(1)}%)`);\n    \n    if (profile.customizationSummary) {\n      console.group('🔧 Customizations');\n      console.log(`Customized columns: ${profile.customizationSummary.customizedColumns}`);\n      console.log('Property usage:', profile.customizationSummary.properties);\n      console.groupEnd();\n    }\n    \n    console.groupEnd();\n  });\n  console.groupEnd();\n  \n  console.group('💰 Overall Savings');\n  console.log(`Total legacy size: ${analysis.overallSavings.totalLegacySizeKB.toFixed(2)} KB`);\n  console.log(`Total lightweight size: ${analysis.overallSavings.totalLightweightSizeKB.toFixed(2)} KB`);\n  console.log(`Total savings: ${analysis.overallSavings.totalSavingsKB.toFixed(2)} KB`);\n  console.log(`Savings percentage: ${analysis.overallSavings.totalSavingsPercent.toFixed(1)}%`);\n  console.groupEnd();\n  \n  console.groupEnd();\n}\n\n// Export function to window for easy console access\nif (typeof window !== 'undefined') {\n  (window as any).analyzeProfileStorage = logStorageAnalysis;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/stores/styleSerializer.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":29,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1018,1021],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1018,1021],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":30,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1077,1080],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1077,1080],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":67,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2204,2207],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2204,2207],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":75,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2615,2618],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2615,2618],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":84,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2953,2956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2953,2956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":92,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":92,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3271,3274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3271,3274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Utility to serialize and deserialize style functions for localStorage\n\nimport { ColDef } from 'ag-grid-community';\n\nexport interface SerializedStyle {\n  type: 'static' | 'function';\n  value?: React.CSSProperties;\n  formatString?: string;\n  baseStyle?: React.CSSProperties;\n}\n\nexport interface SerializedColumnDef extends Omit<ColDef, 'cellStyle' | 'headerStyle'> {\n  cellStyle?: SerializedStyle;\n  headerStyle?: SerializedStyle;\n}\n\n// Serialize a column definition with style functions\nexport function serializeColumnDef(colDef: ColDef): SerializedColumnDef {\n  const serialized = { ...colDef };\n  \n  // Handle cellStyle\n  if (colDef.cellStyle) {\n    if (typeof colDef.cellStyle === 'function') {\n      // Try to extract format string from function (this is a workaround)\n      // In production, you'd want to store the format configuration separately\n      serialized.cellStyle = {\n        type: 'function',\n        // Store function as string for now - we'll need to improve this\n        formatString: (colDef as any)._cellStyleFormat || '',\n        baseStyle: (colDef as any)._cellStyleBase || {}\n      };\n    } else {\n      serialized.cellStyle = {\n        type: 'static',\n        value: colDef.cellStyle as React.CSSProperties\n      };\n    }\n  }\n  \n  // Handle headerStyle\n  if (colDef.headerStyle) {\n    if (typeof colDef.headerStyle === 'function') {\n      serialized.headerStyle = {\n        type: 'function',\n        value: {} // Header style functions typically return empty for floating filters\n      };\n    } else {\n      serialized.headerStyle = {\n        type: 'static',\n        value: colDef.headerStyle as React.CSSProperties\n      };\n    }\n  }\n  \n  return serialized as SerializedColumnDef;\n}\n\n// Deserialize a column definition and recreate style functions\nexport function deserializeColumnDef(serialized: SerializedColumnDef): ColDef {\n  const colDef = { ...serialized };\n  \n  // Handle cellStyle\n  if (serialized.cellStyle && typeof serialized.cellStyle === 'object' && 'type' in serialized.cellStyle) {\n    const styleConfig = serialized.cellStyle as SerializedStyle;\n    \n    if (styleConfig.type === 'static' && styleConfig.value) {\n      colDef.cellStyle = styleConfig.value as any;\n    } else if (styleConfig.type === 'function' && styleConfig.formatString) {\n      // Recreate the cell style function\n      // This is a simplified version - you'd need the actual createCellStyleFunction\n      colDef.cellStyle = (() => {\n        // For now, just return the base style\n        // In production, you'd recreate the conditional logic\n        return styleConfig.baseStyle || {};\n      }) as any;\n    }\n  }\n  \n  // Handle headerStyle\n  if (serialized.headerStyle && typeof serialized.headerStyle === 'object' && 'type' in serialized.headerStyle) {\n    const styleConfig = serialized.headerStyle as SerializedStyle;\n    \n    if (styleConfig.type === 'static' && styleConfig.value) {\n      colDef.headerStyle = styleConfig.value as any;\n    } else if (styleConfig.type === 'function') {\n      // Recreate header style function that avoids floating filter\n      colDef.headerStyle = ((params: { floatingFilter?: boolean }) => {\n        if (params?.floatingFilter) {\n          return null;\n        }\n        return styleConfig.value || {};\n      }) as any;\n    }\n  }\n  \n  return colDef as ColDef;\n}\n\n// Serialize all column definitions\nexport function serializeColumnDefs(columnDefs: ColDef[]): SerializedColumnDef[] {\n  return columnDefs.map(serializeColumnDef);\n}\n\n// Deserialize all column definitions\nexport function deserializeColumnDefs(serialized: SerializedColumnDef[]): ColDef[] {\n  return serialized.map(deserializeColumnDef);\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/types/index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":17,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[362,365],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[362,365],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":18,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[375,378],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[375,378],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":19,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[388,391],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[388,391],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":20,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[403,406],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[403,406],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":21,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[418,421],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[418,421],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":22,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[434,437],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[434,437],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { \n  ValueFormatterParams, \n  ColDef as AgColDef,\n  GridApi,\n  GridReadyEvent,\n  CellValueChangedEvent,\n  SortChangedEvent,\n  FilterChangedEvent,\n  ColumnResizedEvent,\n  ColumnMovedEvent,\n  ColumnPinnedEvent,\n  ColumnVisibleEvent\n} from 'ag-grid-community';\n\n// CellStyleParams type definition for AG-Grid v33+\nexport interface CellStyleParams {\n  value: any;\n  data: any;\n  node: any;\n  colDef: any;\n  column: any;\n  context: any;\n  api: GridApi;\n}\n\n/**\n * Enhanced column definition with required fields\n */\nexport interface ColumnDef extends Omit<AgColDef, 'field' | 'headerName' | 'type'> {\n  field: string;\n  headerName: string;\n  type?: string | string[]; // For legacy/custom use\n  cellDataType?: 'text' | 'number' | 'date' | 'boolean' | string | boolean; // ag-Grid v33+ optimization\n}\n\n/**\n * Metadata attached to formatter functions for serialization\n */\nexport interface FormatterMetadata {\n  __formatString: string;\n  __formatterType: 'excel' | 'visual' | 'custom';\n  __visualRules?: SerializedFormattingRule[];\n  __visualDefaultFallback?: SerializedDefaultFallback;\n}\n\n/**\n * Metadata attached to cell style functions\n */\nexport interface CellStyleMetadata {\n  __formatString?: string;\n  __baseStyle?: React.CSSProperties;\n  __cacheKey?: string;\n}\n\n/**\n * Enhanced formatter function type with metadata\n */\nexport type FormatterFunction = ((params: ValueFormatterParams) => string) & FormatterMetadata;\n\n/**\n * Enhanced cell style function type with metadata\n */\nexport type CellStyleFunction = ((params: CellStyleParams) => React.CSSProperties | undefined) & CellStyleMetadata;\n\n/**\n * Serialized formatting rule for visual formatter\n */\nexport interface SerializedFormattingRule {\n  id: string;\n  condition: {\n    type: 'equals' | 'contains' | 'startsWith' | 'endsWith' | 'greaterThan' | 'lessThan' | 'greaterEqual' | 'lessEqual' | 'between' | 'isEmpty' | 'isNotEmpty';\n    value: string;\n    value2?: string;\n  };\n  display: {\n    type: 'text' | 'original' | 'custom';\n    text: string;\n  };\n  styling: {\n    backgroundColor?: string;\n    textColor?: string;\n    fontSize?: number;\n    fontWeight?: 'normal' | 'bold' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';\n    fontStyle?: 'normal' | 'italic';\n    textDecoration?: 'none' | 'underline' | 'line-through';\n    textAlign?: 'left' | 'center' | 'right';\n    border?: {\n      width: number;\n      style: 'solid' | 'dashed' | 'dotted' | 'double';\n      color: string;\n      sides: {\n        top: boolean;\n        right: boolean;\n        bottom: boolean;\n        left: boolean;\n      };\n    };\n    padding?: {\n      top: number;\n      right: number;\n      bottom: number;\n      left: number;\n    };\n  };\n  enabled: boolean;\n}\n\n/**\n * Serialized default fallback for visual formatter\n */\nexport interface SerializedDefaultFallback {\n  display: {\n    type: 'original' | 'text';\n    text: string;\n  };\n  styling: SerializedFormattingRule['styling'];\n}\n\n/**\n * Props for DataTable component\n */\nexport interface DataTableProps {\n  columnDefs: ColumnDef[];\n  dataRow: Record<string, unknown>[];\n}\n\n/**\n * Context value for DataTable\n */\nexport interface DataTableContextValue {\n  processedColumns: ColumnDef[];\n  selectedFont: string;\n  handleFontChange: (font: string) => void;\n  showColumnDialog: boolean;\n  setShowColumnDialog: (show: boolean) => void;\n  gridApiRef: React.MutableRefObject<GridApi | null>;\n  getColumnDefsWithStyles: () => ColumnDef[];\n  setGridApi?: (api: GridApi | null) => void;\n}\n\n/**\n * Grid event types\n */\nexport type GridEvent = \n  | GridReadyEvent\n  | CellValueChangedEvent\n  | SortChangedEvent\n  | FilterChangedEvent\n  | ColumnResizedEvent\n  | ColumnMovedEvent\n  | ColumnPinnedEvent\n  | ColumnVisibleEvent;\n\n/**\n * Column property type for bulk updates\n */\nexport interface ColumnProperty {\n  key: string;\n  value: unknown;\n  type?: 'style' | 'format' | 'general';\n}\n\n/**\n * Template properties for bulk actions\n */\nexport interface TemplateProperty {\n  property: string;\n  value: unknown;\n  type?: string;\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/utils/constants.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/utils/formatters.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/utils/styleUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/components/datatable/utils/typeGuards.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[733,736],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[733,736],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[766,769],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[766,769],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":31,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[876,879],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[876,879],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":32,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[923,926],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[923,926],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[969,972],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[969,972],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1023,1026],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1023,1026],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":51,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":51,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1362,1365],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1362,1365],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":52,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1405,1408],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1405,1408],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":53,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1444,1447],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1444,1447],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":9,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { FormatterFunction, CellStyleFunction } from '../types';\n\n/**\n * Type guard to check if a function is a formatter with metadata\n */\nexport function isFormatterFunction(fn: unknown): fn is FormatterFunction {\n  return typeof fn === 'function' && '__formatString' in fn;\n}\n\n/**\n * Type guard to check if a function is a cell style function with metadata\n */\nexport function isCellStyleFunction(fn: unknown): fn is CellStyleFunction {\n  return typeof fn === 'function' && ('__formatString' in fn || '__baseStyle' in fn);\n}\n\n/**\n * Safely extract formatter metadata from a function\n */\nexport function getFormatterMetadata(fn: unknown): {\n  formatString?: string;\n  formatterType?: 'excel' | 'visual' | 'custom';\n  visualRules?: any[];\n  visualDefaultFallback?: any;\n} | null {\n  if (!isFormatterFunction(fn)) {\n    return null;\n  }\n  \n  return {\n    formatString: (fn as any).__formatString,\n    formatterType: (fn as any).__formatterType,\n    visualRules: (fn as any).__visualRules,\n    visualDefaultFallback: (fn as any).__visualDefaultFallback,\n  };\n}\n\n/**\n * Safely extract cell style metadata from a function\n */\nexport function getCellStyleMetadata(fn: unknown): {\n  formatString?: string;\n  baseStyle?: React.CSSProperties;\n  cacheKey?: string;\n} | null {\n  if (!isCellStyleFunction(fn)) {\n    return null;\n  }\n  \n  return {\n    formatString: (fn as any).__formatString,\n    baseStyle: (fn as any).__baseStyle,\n    cacheKey: (fn as any).__cacheKey,\n  };\n}","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/hooks/use-mobile.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/hooks/use-toast.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/lib/utils.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[372,375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[372,375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":12,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[382,385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[382,385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { clsx, type ClassValue } from 'clsx';\nimport { twMerge } from 'tailwind-merge';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\n/**\n * Debounce function that delays invoking func until after wait milliseconds\n * have elapsed since the last time the debounced function was invoked.\n */\nexport function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeoutId: NodeJS.Timeout | undefined;\n\n  return function debounced(...args: Parameters<T>) {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      func(...args);\n    }, wait);\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"/Users/andyrao/Documents/projects/agv1/src/vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
